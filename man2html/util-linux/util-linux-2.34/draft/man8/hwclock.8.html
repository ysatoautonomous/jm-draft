<HTML>
  <HEAD>
  <META CHARSET="UTF-8"/>
  <META HTTP-QUIV="Content-Type" CONTENT="text/html; charset=UTF-8"/>
  <LINK REL="stylesheet" TYPE="text/css"
	    HREF="../../../../css/jm-draft.css"/>
  <TITLE>Manpage of HWCLOCK</TITLE>
</HEAD><BODY>
<H1>HWCLOCK</H1>
Section: System Administration (8)<BR>Updated: July 2017<BR><A HREF="#index">Index</A>
<A HREF="https://github.com/ysatoautonomous/jm-draft/wiki">Return to Main Contents</A><HR>



<A NAME="lbAB">&nbsp;</A>
<H2>名前</H2>

hwclock - タイムクロックのユーティリティ

<A NAME="lbAC">&nbsp;</A>
<H2>書式</H2>

<B>hwclock</B>

[<I>function</I>]

[<I>option</I>...]


<A NAME="lbAD">&nbsp;</A>
<H2>説明</H2>









<B>hwclock</B>

はタイムクロックの管理ツールである。
以下のことが実行できる。
ハードウェア・クロックの値を、ずれの値に基づいて表示する。
ハードウェア・クロックの値を、指定した時刻に設定する。
ハードウェア・クロックの値を、システム・クロックの値に設定する。
システム・クロックの値を、ハードウェア・クロックの値に設定する。
ハードウェア・クロックのずれを補償する。
システム・クロックのタイムスケールを訂正する。
カーネルのタイムゾーン、NTP タイムスケール、紀元年 (Alpha のみ) を設定する。
将来のハードウェア・クロックの値を、ずれの値に基づいて、予想する。
<P>








v2.26 から重要な変更が、
<B>--hctosys</B>

の機能と
<B>--directisa</B>

オプションに対して行われ、新しいオプション
<B>--update-drift</B>

が追加された。
下記ののそれぞれの説明を参照すること。

<A NAME="lbAE">&nbsp;</A>
<H2>機能</H2>



以下の機能は排他であり、1 度に 1 つしか設定できない。
何も指定されない場合、デフォルトは <B>--show</B> である。
<DL COMPACT>
<DT><B>-a, --adjust</B>

<DD>




最後にハードウェア・クロックを合わせた時点からの経過時間に対して生じる、
時計の規則的なずれを補償するために、
一定の時間をハードウェア・クロックの時刻から増減する。
詳細は以下の
<B>時刻合わせ機能</B>

の議論を参照のこと。
<DT><B>--getepoch</B>

<DD>

<B>--setepoch</B>



この機能は Alpha マシンのみであり、
Linux カーネル RTC ドライバを通じてのみ利用可能である。
<P>





この機能では、カーネルのハードウェア・クロックの紀元年の値の
読み込みと設定を行う。
紀元年は西暦の何年が、ハードウェア・クロックの
0 年として参照されるかを示す数値である。
例えば、マシンの BIOS がハードウェア・クロックの年カウンタに
1952 年以降の経過年数を用いている場合には、
カーネルでのハードウェア・クロック紀元年は 1952 でなければならない。
<P>



<B>--setepoch</B> の機能は、年を指定するために、
<B>--epoch</B>

オプションを使う必要がある。
例:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
<B>hwclock&nbsp;--setepoch&nbsp;--epoch=1952</B>

</DL>
<P>



RTC ドライバは現在の紀元年を値を推定しようとするので、設定する必要はない。
<P>





この紀元年の値は、
<B>hwclock</B>

が Alpha マシンでハードウェア・クロックを読み書きするとき常に用いられる。
ISA マシンでは、カーネルは固定のハードウェア・クロックの紀元年として、
1900 年を用いる。
</DL>

<DT><B>--predict</B>

<DD>





<B>--date</B>

オプションと
<I>/etc/adjtime</I>

の情報に基づいて、ハードウェア・クロックが将来読み出す値を予測する。



例えば、ハードウェア・クロックのウェイクアップ (別名、アラーム) を設定する時に、
ずれを考慮するのに役立つ。
<B><A HREF="../man8/rtcwake.8.html">rtcwake</A></B>(8)

を参照すること。
<P>




ハードウェア・クロックを現在のオペレーティングシステムの
<B>hwclock</B>

コマンドから変更しない場合、
例えば '11&nbsp;分モード' またはデュアルブートした他の OS から変更する場合、
この機能を使ってはならない。
<DT><B>-r</B>,<B>&nbsp;--show</B>

<DD>

<B>--get</B>

<BR>




ハードウェア・クロックを読んで、時刻を
<B>ISO 8601</B>

フォーマットで標準出力に表示する。




ハードウェア・クロックを協定世界時 (UTC) にしていても、
表示はローカル・タイムである。
<B>--localtime</B>

オプションを参照すること。
<P>

ハードウェア・クロック時刻を表示するのは、
どの機能も指定されてない場合のデフォルトである。
<P>





<B>--get</B>

機能は、時刻の読み出しを行う際に、
<I>/etc/adjtime</I>

の情報に基づいてずれの補正を適用する。




ハードウェア・クロックを現在のオペレーティングシステムの
<B>hwclock</B>

コマンドから変更しない場合、
例えば '11&nbsp;分モード' またはデュアルブートした他の OS から変更する場合、
この機能を使ってはならない。
<DT><B>-s</B>,<B>&nbsp;--hctosys</B>

<DD>




システム・クロックをハードウェア・クロックに合わせる。
ハードウェア・クロックから読み出した時刻は、
システム・クロックに設定される前に、
規則的なずれ (systematic drift) を考慮して補正される。
下記の
<B>時刻合わせ機能</B>

での議論を参照すること。
<P>












システム・クロックは UTC タイムスケールで保持される。
これにより、日付時刻のアプリケーションは、
システムに設定されたタイムゾーンと組み合わされて、正しく動作する。
ハードウェア・クロックがローカル時刻で保持されている場合、
システム・クロックに設定する前に、
読み出した時刻を UTC タイムケールにシフトさせなければならない。
<B>--hctosys</B>

の機能は、これを
<I>/etc/adjtime</I>

ファイル、またはコマンドライン引き数
<B>--localtime</B> と <B>--utc</B>

の情報に基づいて行う。
注意: 夏時間の補正は行われない。
下記の
<B>ローカル時刻 vs UTC</B>

の議論を参照すること。
<P>











カーネルはタイムゾーンの値を保持し、
<B>--hctosys</B>

の機能でシステムに設定されるタイムゾーンに設定する。
システムのタイムゾーンは、TZ 環境変数や
<I>/etc/localtime</I>

ファイルで設定され、
<B><A HREF="../man3/tzset.3.html">tzset</A></B>(3)

と同じように解釈される。
カーネルのタイムゾーンの obsolete なフィールドである
tz_dsttime は 0 に設定される。
(このフィールドがかつて意味していた内容に関しては
<B><A HREF="../man2/settimeofday.2.html">settimeofday</A></B>(2)

を参照のこと。)
<P>










起動スクリプト内で使用される場合、ブートからの
<B>--hctosys</B>

機能の最初の呼び出しを、
<B><A HREF="../man2/settimeofday.2.html">settimeofday</A></B>(2)

にする。
これは、
<I>persistent_clock_is_local</I>

カーネル変数を使って、NTP の '11&nbsp;分モード' タイムスケールを設定する。
ハードウェア・クロックのタイムスケール設定が変更された場合、
カーネルに通知するためには再起動が必要である。
下記の
<B>カーネルによるハードウェア・クロックの自動同期</B>

の議論を参照すること。
<P>


これはファイルシステムを read/write でマウントする前に、
システムの起動スクリプトで使うのによい機能である。
<P>





この機能は実行中のシステムに使うべきではない。
システム時刻が飛んでしまうと、ファイルシステムのタイムスタンプが
破損するといった問題を引き起こす。
NTP の '11&nbsp;分モード' のように、
何かがハードウェア・クロックを変更すると、
<B>--hctosys</B>

は、ずれの補償を含めて時刻を正しく設定できない。
<P>








ずれの補償は、
<I>/etc/adjtime</I>

のずれの要素を 0 に設定することで、中止することができる。
この設定は、シャットダウン時に (またはどこかで)
<B>--update-drift</B>

オプションが
<B>--systohc</B>

と一緒に指定されるまで継続する。
もう 1 つのずれの補償をさせない方法は、
<B>--hctosys</B>

機能の呼び出しで、
<B>--noadjfile</B>

オプションを使うことである。
3 番目の方法は、
<I>/etc/adjtime</I>

ファイルを削除することである。








この場合、
<B>hwclock</B>

はデフォルトでハードウェア・クロックで UTC タイムスケールを使う。
ハードウェア・クロックがローカル時刻で刻まれている場合、
このファイルで定義されている必要がある。
ファイルが存在しない場合、
<B>hwclock&nbsp;--localtime&nbsp;--adjust</B>;

を呼び出すことでローカル時刻にすることができる。
このコマンドは実際にはハードウェア・クロックを調整せず、
ローカル時刻の設定がされて、ずれ要素が 0 のファイルを生成する。
<P>






<B>hwclock</B>

のずれ補正を中止する条件は、複数のオペレーティングシステムを
デュアルブートする時に、望ましい効果がある。
Linux のインスタンスが停止して、他の OS がハードウェア・クロックの値を変更した場合、
Linux のインスタンスを再度起動したときに、適用されるずれ補正が不正になる。
<P>



<B>hwclock</B>

のずれ補正が正しく動作するには、Linux インスタンスが動作していないときに、
ハードウェア・クロックが変更されないことが、絶対必要である。
<DT><B>--set</B>

<DD>




ハードウェア・クロックを
<B>--date</B>

オプションで指定した時刻に設定し、
<I>/etc/adjtime</I>

のタイムスタンプを更新する。




<B>--update-drift</B>

オプションを指定すると、ずれの要素を (再) 計算する。
このオプションを指定しないと、
<B>--set</B>

は失敗する。
以下の
<B>--update-drift</B>

を参照すること。
<DT><B>--systz</B>

<DD>







これは
<B>--hctosys</B>

機能の代替である。
これはハードウェア・クロックの読み出しと、
システム・クロックの設定も行わない。
結果として、ずれの補正を行わない。
この機能は、バージョン 2.6 以降のカーネルのシステムの起動スクリプトで使うことを意図している。
このシステムでは、カーネルの起動時に、
システム・クロックがハードウェア・クロックの値に設定される。
<P>


上記の
<B>--hctosys</B>

機能では、詳細には以下に示すことが行われている:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>&bull;<DD>




システム・クロックのタイムスケールを必要に応じて UTC に補正する。
システム・クロックを設定することで、これを行う代わりに、
<B>hwclock</B>

はカーネルに単純に通知を行い、変更を行う。
<DT>&bull;<DD>

カーネルの NTP '11&nbsp;分モード' タイムスケールを設定する。
<DT>&bull;<DD>

カーネルのタイムゾーンを設定する。
</DL>
<P>






最初の 2 つは、起動後の最初の
<B><A HREF="../man2/settimeofday.2.html">settimeofday</A></B>(2)

の呼び出しで実行される。
結果として、このオプションは起動スクリプトで使われる場合にのみ
意味を持つ。
ハードウェア・クロックのタイムスケール設定が変更された場合、
カーネルに通知するために再起動が必要である。
</DL>

<DT><B>-w</B>,<B>&nbsp;--systohc</B>

<DD>


ハードウェア・クロックをシステム・クロックに設定し、
<I>/etc/adjtime</I>

のタイムスタンプを更新する。




<B>--update-drift</B>

オプションを指定すると、ずれの要素を (再) 計算する。
このオプションを指定せずに、
<B>--systohc</B>

を実行すると失敗する。
下記の
<B>--update-drift</B>

を参照すること。
<DT><B>-V</B>,<B>&nbsp;--version</B>

<DD>

バージョン情報を表示して、終了する。
<DT><B>-h</B>,<B>&nbsp;--help</B>

<DD>

ヘルプを表示して、終了する。

</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>オプション</H2>

<DL COMPACT>
<DT><B>--adjfile=</B><I>filename</I>

<DD>

デフォルトの
<I>/etc/adjtime</I>

ファイルパスを上書きする。
<DT><B>--date=</B><I>date_string</I>

<DD>





このオプションは
<B>--set</B>

または
<B>--predict</B>

機能と一緒に使わなければならない。
さもなければ、このオプションは無視される。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
<B>hwclock&nbsp;--set&nbsp;--date='16:45'</B>

<DT><DD>
<B>hwclock&nbsp;--predict&nbsp;--date='2525-08-14&nbsp;07:11:05'</B>

</DL>
<P>





ハードウェア・クロックを UTC にしたい場合でも、引き数はローカル時刻でなければならない。
<B>--localtime</B>

オプションを参照すること。
よって、引き数にはタイムゾーンの情報を含めるべきではない。






また、引き数を &quot;+5 minutes&quot; のように相対時刻にするべきでもない。
なぜなら
<B>hwclock</B>

の精度は、引き数の値とキーが押された時の関係に依存しているからである。
小数で指定した秒は、黙って落とされる。
このオプションは、多くの時刻と日付のフォーマットを解釈できるが、
前のパラメータに従う。
</DL>

<DT><B>--delay=</B><I>seconds</I>

<DD>




このオプションを使うと、クロック時刻を設定する際に、
内部的に使われる遅延を上書きすることができる。
デフォルトの遅延は、rtc_cmos については 0.5 (500ms) であり、
他の RTC タイプについては 0 である。
RTC タイプが (sysfs から) 決定できない場合、
後方互換性のため、デフォルトを 0.5 にする。
<DL COMPACT><DT><DD>
<P>








500ms のデフォルトは、一般に用いられている MC146818A 互換 (x86)
ハードウェア・クロックに基づいている。
ハードウェア・クロックは任意の整数の時刻プラス 0.5 秒にのみ設定できる。
小数の秒を設定または取得するインタフェースがないので、
整数の時刻にする必要がある。
追加される 0.5 秒の遅延は、新たな時刻が設定されてから正確に 500ms 後に、
ハードウェア・クロックが更新されるからである。
残念なことに、この挙動はハードウェア依存であり、
同様な場合にも別の遅延時間が必要になる。
</DL>

<DT><DT><B>-D</B>, <B>--debug</B>

<DD>
<DD>

<B>--verbose</B>

を使うこと。


<B>--debug</B>

オプションは古く、将来のリリースで、別の目的に使われるか、
削除される。
<DT><B>--directisa</B>

<DD>




このオプションは、x86 と x86_64 ファミリーの ISA 互換マシンでのみ意味を持つ。
他のマシンでは、何の効果もない。
このオプションは
<B>hwclock</B>

に指令して、ハードウェア・クロックへのアクセスに
直接 I/O 命令を用いるようにさせる。










このオプションを指定しないと、
<B>hwclock</B>

は rtc デバイスを用いようとする
(rtc が RTC デバイスドライバで駆動されていることを仮定する)。
v2.26 以降では、rtc ドライバが利用できない場合、
directisa を自動で使わなくなった。
これを使うと、2 つのプロセスが同時にハードウェア・クロックにアクセスするのを
許可してしまい、安全でない条件が生み出されてしまうからである。
ユーザー空間からの直接ハードウェアアクセスは、
テストして、トラブルシュートして、他の全ての手段が失敗した場合の
最後の手段として使うべきである。
<B>--rtc</B>

オプションを参照すること。
<DT><B>--epoch=</B><I>year</I>

<DD>





このオプションは
<B>--setepoch</B>

機能を使うときに必要である。
<I>year</I>

の最小値は 1900 である。
最大値はシステム依存で
(<B>ULONG_MAX&nbsp;-&nbsp;1</B>)

である。
<DT><B>-f</B>,<B>&nbsp;--rtc=</B><I>filename</I>

<DD>



<B>hwclock</B>

のデフォルトの rtc デバイスファイル名を上書きする。
指定しない場合、下記の順で見つかった最初のものを使う:

<BR>

<I>/dev/rtc0</I>

<BR>

<I>/dev/rtc</I>

<BR>

<I>/dev/misc/rtc</I>

<BR>



<B>IA-64</B> の場合:


<BR>

<I>/dev/efirtc</I>

<BR>

<I>/dev/misc/efirtc</I>


<DT><B>-l</B>,<B>&nbsp;--localtime</B>

<DD>

<B>-u</B>, <B>--utc</B>


ハードウェア・クロックがどちらのタイムスケールを使うかを指定する。
<P>









ハードウェア・クロックは、UTC またはローカルのいずれかのタイムスケールを使うように設定できる。
しかし、クロック自身がどちらが使われているかを返すことはない。
<B>--localtime</B> または <B>--utc</B>

オプションは、この情報を
<B>hwclock</B>

コマンドに伝える。
間違ったオプションを指定すると
(またはどちらも指定せず、間違ったデフォルトが使われると)、
ハードウェア・クロックの設定も読み出しも不正になる。
<P>







<B>--utc</B> も <B>--localtime</B>

も指定しない場合、最後に set 機能
(<B>--set</B>, <B>--systohc</B>, <B>--adjust</B>)

を実行した時に使われたオプションが使われる。
これは
<I>/etc/adjtime</I>

に記録されている。
adjtime ファイルが存在しない場合、デフォルトは UTC である。
<P>



注意: ハードウェア・クロックがローカル時間で保持されている場合、
夏時間への変更は不整合を起こす。
下記の
<B>ローカル時刻 vs UTC</B>

の議論を参照すること。
<DT><B>--noadjfile</B>

<DD>


<I>/etc/adjtime</I>

によって提供される機能を無効にする。




このオプションを使うと、
<B>hwclock</B>

は
<I>/etc/adjtime</I>

の読み込みも書き込みもしない。
このオプションを使うときは、
<B>--utc</B> または <B>--localtime</B>

を指定しなければならない。
<DT><B>--test</B>

<DD>




実際にはシステム、つまりクロックまたは
<I>/etc/adjtime</I>

に変更は行わない
(<B>--verbose</B>

は暗黙のうちにこのオプションを指定する)。
<DT><B>--update-drift</B>

<DD>




<I>/etc/adjtime</I>

に書かれたハードウェア・クロックのずれの要素を更新する。
このオプションは
<B>--set</B> または <B>--systohc</B>

とのみ一緒に利用できる。
<P>



設定には、最小限 4 時間の期間を開ける必要がある。
これは計算を不正にしないためである。
期間を長くするほど、ずれの要素の計算結果は正確になる。
<P>





このオプションは、v2.26 で追加された。
なぜなら、システムで
<B>hwclock&nbsp;--systohc</B>

をシャットダウン時に呼び出すことが典型的にあり、
以前の挙動では、ずれの要素を自動的に (再) 計算しており、
問題を引き起こしていた:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>&bull;<DD>


NTP を '11&nbsp;分モード' を使っている場合、
カーネルのずれ要素は 0 に近い値にされる。
<DT>&bull;<DD>







「コールド」ずれ補正を使うことを許可しない。
「コールド」ずれ補正を使う多くの設定では、良好な結果を生み出す。
「コールド」とは、ずれ要素に重大な影響がある場合に、
マシンを停止することを意味している。
<DT>&bull;<DD>






シャットダウン毎にずれ要素を (再) 計算することは、準最適な結果を生み出す。
例えば、短期間しか使われない条件は、
マシンの異常でホットなずれ要素の計算で、範囲外にしてしまう。
<DT>&bull;<DD>




(v2.31 の時点で
<B>--update-drift</B>

を使わず、RTC が読み込まれない場合)
シャットダウンの時間が顕著に長くなる。
</DL>
<P>










<B>hwclock</B>

にずれ要素を計算させるのは、良いスタートポイントとなるが、
最適な値に調整するには、
<I>/etc/adjtime</I>

ファイルを直接編集する必要がある。
多くの設定では、一度マシンの最適なずれ要素が作られれば、
変更する必要はない。
よって、自動的にずれを (再) 計算する以前の挙動は変更され、
今はこのオプションを使う必要がある。
下記の
<B>時間調整の機能</B>

の議論を参照すること。
<P>







このオプションは、ハードウェア・クロックを設定する前に読み込む
必要がある。
読み込めない場合、このオプションは設定機能を失敗させる。
これは、例えば、電源の障害でハードウェア・クロックが壊れている
場合に起こる。
この場合、このオプションなしで最初にクロックを設定しなければ
ならない。
これが動作しない場合、ずれの補正要素はどうしても不正になる。
</DL>

<DT><B>-v</B>, <B>--verbose</B>

<DD>



<B>hwclock</B>

が内部で実行していることをより詳細に表示する。

</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>注意</H2>


<A NAME="lbAH">&nbsp;</A>
<H3>Linux システムにおける時計</H3>

<P>


2 つタイプの日付時刻の時計がある:
<P>


<B>ハードウェア・クロック: </B>




このクロックは独立したハードウェアデバイスで、
独自の電源系統 (電池、コンデンサーなど) を持っており、
マシンが電源オフされたり、電源プラグが抜かれた場合でも、動作する。
<P>





ISA 互換のシステムでは、このクロックは ISA 規格の一部として定義されている。
コントロールプログラムはこの時計に対して 1 秒単位で読み書きできるが、
秒針の変化を検出することもできるので、
実際には仮想的に無限大の精度を持っていることになる。
<P>





この時計は一般にハードウェア・クロック、リアルタイム・クロック、RTC、
BIOS クロック、CMOS クロックなどと呼ばれる。
<B>hwclock</B>

では「ハードウェア・クロック (原文では Hardware Clock)」を用いる。

Linux カーネルは永続 (persistent) クロックも参照する。
<P>






非 ISA システムではいくつかのリアルタイムクロックがあり、
その中の一つが独自の電源系統を持っている。
超低電力の外部 I2C または SPI クロックチップが、
ハードウェア・クロックとしてバックアップバッテリーとともに使われ、
より多くの目的で使われる高機能の統合されたリアルタイムクロックを初期化する。
<P>


<B>システム・クロック: </B>








この時計は Linux カーネルの一部で、
タイマ割り込みによって駆動されている
(ISA システムでは、タイマ割り込みは ISA 標準の一部である)。
すなわち Linux が起動している間しか動作しない。
システム時刻は UTC 1970/01/01 00:00:00 からの経過秒数である
(より簡単に言えば UTC 1969 年終了後の経過秒数である)。
しかしシステム時刻は整数ではなく、仮想的に無限大の精度を持っている。
<P>


<P>




<P>



<P>
Linux ではシステム・クロックがすべての基準となる時計である。
ハードウェア・クロックの基本的な役割は、システムが動いていない間にも
時計を動かしつづけることである。
そのため、起動時にシステム・クロックを初期化する。
ISA システムの設計対象であった DOS においては、
ハードウェア・クロックがただ一つの実時間時計であることに注意すること。
<P>










システム・クロックには不連続が存在してはならない。
これはシステムが走っている間に
<B><A HREF="../man1/date.1.html">date</A></B>(1)

プログラムを実行して時計を合わせるような場合でも同様である。
一方ハードウェア・クロックには、システムの実行中にでも何を行ってもよい。
次回 Linux が起動したときに、
ハードウェア・クロックからこの調整された時間が使用される。
注意: 
<B>hwclock&nbsp;--systohc</B>

がシャットダウン時に呼ばれるので、
これは現在のところ大部分のシステムで利用できない。
<P>



Linux カーネルのタイムゾーンは、
<B>hwclock</B>

で設定される。








しかし注意してほしい -- 
「カーネルが自分をどのタイムゾーンにいると思っているか」など、
誰も気にしていないのである。代わりに、タイムゾーンに関わるプログラム
(おそらくローカルな時間を表示しようとしているもの) は、
ほぼ間違いなく従来用いられてきた方法でタイムゾーンを決定する。
つまり TZ 環境変数や
<I>/etc/localtime</I>

ファイルを、
<B><A HREF="../man3/tzset.3.html">tzset</A></B>(3)

で説明されているようなやり方で参照するのである。




しかしカーネルのタイムゾーンの値を見るプログラムも存在するし、
カーネルの周辺部分 (ファイルシステムなど) もこちらを参照する。
vfat ファイルシステムなどがそうである。カーネルのタイムゾーンの
値が間違っていると、vfat ファイルシステムはファイルのタイムスタンプの
設定・取得を間違ってしまう。
他の例は、カーネルの NTP '11&nbsp;分モード' である。





カーネルのタイムゾーンの値と
<I>persistent_clock_is_local</I>

変数が間違えている場合、ハードウェア・クロックが
'11&nbsp;分モード' で設定が不正になる。
下記の
<B>カーネルによるハードウェア・クロックの自動同期</B>

の議論を参照すること。
<P>





<B>hwclock</B>

は
<B>--hctosys</B> または <B>--systz</B> の機能で

カーネルのタイムゾーンを TZ や
<I>/etc/localtime</I>

の値に設定する。
<P>









カーネルのタイムゾーンの値は実際には 2 つの部分からなる。
1) tz_minuteswest フィールド: (DST でない)
ローカルタイムが UTC から何分遅れているかを表す。
2) tz_dsttime: 夏時間 (DST) の形式を表し、
現在地の現在時刻に影響する。
この 2 番目のフィールドは Linux では用いられず、常に 0 となる。
<B><A HREF="../man2/settimeofday.2.html">settimeofday</A></B>(2)

も参照のこと。

<A NAME="lbAI">&nbsp;</A>
<H3>ハードウェア・クロックへのアクセス方法</H3>

<P>









<B>hwclock</B>

はハードウェア・クロック時刻の取得や設定に、いろいろな方法を用いる。
もっとも普通のやり方は、rtc デバイススペシャルファイルに対して 
I/O を行う方法である。
これは rtc デバイスドライバで動作することを前提としている。
Linux システムは、udev と複数のハードウェア・クロックをサポートする
rtc フレームワークも使う。
<B><BR>&nbsp;--rtc</B>

オプションで指定することで、デフォルトの rtc デバイスを上書きできる。
<P>




しかし、この方法は古いシステムでは rtc ドライバがないので、利用できない。
これらのシステムでは、ハードウェア・クロックへのアクセス方法は
システムのハードウェアに依存している。
<P>









ISA 互換システムでは、
<B>hwclock</B>

は時計を構成していた「CMOS メモリ」のレジスタに直接アクセスすることができた
(ポート 0x70 と 0x71 に I/O を行う)。
これを行うには
<B>hwclock</B>

の実効ユーザー ID がスーパーユーザーでなければならない。
この方法は、
<B>--directisa</B>

オプションを指定することで使用できる。
<P>




これはクロックにアクセスするには本当に貧弱な方法で、
ユーザー空間プログラムが一般に直接 I/O がサポートされず、
割り込みが禁止されている理由となっている。




<B>hwclock</B>

は、これをテスト、トラブルシュートのために提供しており、
動作している rtc デバイスドライバがない場合に
ISA システムでアクセスを行う唯一の方法になる。

<A NAME="lbAJ">&nbsp;</A>
<H3>時刻合わせ機能</H3>

<P>







通常ハードウェア・クロックはそれほど正確なものではない。
しかし、その「不正確さ」は完全に予測できるものである。
すなわち、時計は一日あたり同じ時間だけ進む（あるいは遅れる）のである。
これを規則的なずれ (systematic drift) と呼ぶことにする。
<B>hwclock</B> の <B>--adjust</B>

の機能は、この規則的なずれに対応する補正量を求め、
ハードウェア・クロックに適用する。
<P>





以下に動作原理を述べる。
<B>hwclock</B>

は
<I>/etc/adjtime</I>

というファイルを管理し、そこに履歴情報を保管する。
このファイルを adjtime ファイルと呼ぶ。
<P>


























adjtime ファイルがない状態から話をはじめる。
<B>hwclock&nbsp;--set</B>

コマンドを用いてハードウェア・クロックを現在の正しい値に合わせたとする。
このとき
<B>hwclock</B>

は adjtime ファイルを作成し、そこに現在の時刻を「最後に時計合わせ
(calibration) が行われた時刻」として記録する。
5 日後に時計は 10 秒進んだとし、それを修正するために再び
<B>hwclock&nbsp;--set&nbsp;--update-drift</B>

が実行されたとする。
<B>hwclock</B>

は adjtime ファイルを更新し、
現在の時刻を最後に時計合わせが行われた時刻として記録、
同時に 2 秒/日という値を規則的なずれの値として記録する。
24 時間が経過したときに
<B>hwclock&nbsp;--adjust</B>

コマンドを実行すると、
<B>hwclock</B>

は adjtime ファイルを参照し、放っておかれた時計は一日に 2 秒進むこと、
時計はちょうど一日だけ放置されていたことを読みとる。
そこで
<B>hwclock</B>

はハードウェア・クロックから 2 秒を差し引き、現在の時刻を時計の補正 
(adjustment) が行われた時刻として記録する。
さらに 24 時間が経過したときに
<B>hwclock&nbsp;--adjust</B>

を実行すれば、
<B>hwclock</B>

はまた同じことを行う。
つまり 2 秒を差し引き、現在の時刻を adjtime ファイルに書き込む。
<P>








<B>--update-drift</B> オプションを <B>--set</B> または <B>--systohc</B>

と使うと、規則的なずれの割合が、完全にずれ補正された
現在のハードウェア・クロックの時間を、新しく設定した時間と比較することで、
(再) 計算される。
これにより、adjtime にある最後に補正されたタイムスタンプに基づいて、
24 時間のずれの割合を計算する。
そして、このずれ要素は
<I>/etc/adjtime</I>

に保存される。
<P>









ハードウェア・クロックが設定される時に、少しのエラーが生じる。
そのため、
<B>--adjust</B>

は調整を 1 秒以内に収める。
その後、再度調整をする時に、累積したずれが 1 秒以上の場合、
<B>--adjust</B>

は小数のずれを含めて調整する。
<P>












<B>hwclock&nbsp;--hctosys</B>

も、ハードウェア・クロックから読み取って、システム・クロックに設定する前に、
adjtime ファイルデータを使う。
これは、
<B>--adjust</B>

の 1 秒の制限を共有せず、1 秒以下のずれの値を補正する。
このオプションは、ハードウェア・クロックも adjtime ファイルも変更しない。
システムがハードウェア・クロックを補正する必要がなければ、
<B>--adjust</B>

を使う必要性もなくなる。

<A NAME="lbAK">&nbsp;</A>
<H3>adjtime ファイル</H3>





調整のみを行うという歴史的な目的で名前が付けられているが、
<B>hwclock</B>

の 1 回の呼び出しから次の呼び出しで使われる
他の情報も格納されている。
<P>


adjtime は ASCII ファイルであり、フォーマットは以下の通り:
<P>







1 行目は 3 つの数値からなり、それぞれ空白で区切られる:
1) 1 日あたりに生じる規則的な時刻ずれを秒で表したもの (浮動小数点型 10 進):
2) 最後に補正あるいは時計合わせを行った時刻を 
1969 UTC からの経過秒数で表したもの (10 進整数):
3) 10 進整数の 0
(<B><A HREF="../man8/clock.8.html">clock</A></B>(8)

との互換性のためのもの)
<P>






2 行目: 数値が 1 つ: 最後に時計を合わせた時刻を
1969 UTC からの経過秒数で表したもの。
時計合わせが一度もされていなかったり、以前の時計合わせに問題があった
(例えばその時計合わせ以降にハードウェア・クロックの
時刻が不正なことがわかったとかの) 場合には 0 が入る。
これは 10 進の整数である。
<P>






3 行目: &quot;UTC&quot; または &quot;LOCAL&quot;。ハードウェア・クロックが
協定世界時かローカルタイムかを示す。
この値は
<B>hwclock</B>

にコマンドラインを指定すればいつでも上書き可能である。
<P>







以前
<B><A HREF="../man8/clock.8.html">clock</A></B>(8)

で使っていた adjtime ファイルは
<B>hwclock</B>

でもそのまま使うことができる。

<A NAME="lbAL">&nbsp;</A>
<H3>カーネルによるハードウェア・クロックの自動合わせ</H3>

<P>









ハードウェア・クロックを正しい値に同期させるのに、
別法が取れるようなシステムもある。
Linux カーネルには、11 分ごとにシステム・クロックを
ハードウェア・クロックにコピーするようなモードが存在する。
このモードはコンパイル時オプションであるので、
全てのカーネルがこの機能を持っているわけではない。
これは、何らかの洗練された方法 (NTP など) でシステム・クロックを
同期できている時には、よいモードであろう。
(NTP とは、ネットワークのどこかにあるタイムサーバーか、システムに付属した
電波時計にシステム・クロックを同期させる手法である。RFC 1305 を見よ。)
<P>








カーネルが '11&nbsp;分モード' オプションを付けてコンパイルされていると、
カーネルのクロック discipline が同期状態の場合に、
アクティブになる。
この状態になると、カーネルの
<I>time_status</I>

変数のビット 6 (マスク 0x0040 でセットされるビット) がクリアされる。
この値は、
<B>adjtimex&nbsp;--print</B> または <B>ntptime</B>

コマンドの 'status' 行として出力される。
<P>









これには外部への影響がある。
NTP デーモンはカーネルのクロック discipline を同期状態にするので、
'11&nbsp;分モード' を有効にする。
'11&nbsp;分モード' は、
<B>hwclock&nbsp;--hctosys</B>

を含めて、システム・クロックを昔のやり方で設定すると、無効になる。
しかし、NTP デーモンがまだ動作していると、
'11&nbsp;分モード' を有効に戻し、システム・クロックを同期させる。
<P>







'11&nbsp;分モード' を有効にしてシステムが動作している場合、
特にハードウェア・クロックがローカルタイムスケールを使うように
設定されている場合、
<B>--hctosys</B> または <B>--systz</B>

を起動スクリプトで使う必要がある。
ハードウェア・クロック使われているタイムスケールをカーネルに
通知しない限り、間違えたものを使う可能性がある。
カーネルは UTC をデフォルトとして使う。
<P>










システム・クロックを設定するユーザー空間コマンドが、
ハードウェア・クロックが使うタイムスケールが何かをカーネルに通知する。
これは
<I>persistent_clock_is_local</I>

カーネル変数で通知される。
<B>--hctosys</B> または <B>--systz</B>

が最初の場合、adjtime ファイル、または適切なコマンドライン引き数に基づいて
この変数を設定する。
この機能を使って、ハードウェア・クロックのタイムスケール設定を
変更した場合、カーネルに通知するためには、再起動が必要である。
<P>



<B>hwclock&nbsp;--adjust</B>

は NTP '11&nbsp;分モード' と一緒に使うべきではない。

<A NAME="lbAM">&nbsp;</A>
<H3>ISA ハードウェア・クロックの「世紀値 (Century value)」</H3>

<P>








その手の標準の中には、ISA マシンの CMOS 50 バイト目を、
現在の世紀の指標として定義しているものがある。
<B>hwclock</B>

は、このバイトの読み書きを行わない。
なぜならこのバイトをそのようには利用していないマシンが存在するし、
いずれにしてもこれは実際には必要ないからである。
年の世紀の部分を使えば、現在の世紀を特定するには充分である。
<P>




もしこの CMOS の世紀バイトの利用ルーチンを開発した (したい) 方がいたら、
<B>hwclock</B>

のメンテナに連絡してほしい。
オプションを付加することは望ましいことであるから。
<P>



このセクションが意味を持つのは、ハードウェア・クロックに
&quot;direct ISA&quot; によってアクセスしている場合だけであることに注意。


ACPI がハードウェアでサポートされている場合、
世紀値にアクセスする標準的な方法を提供する。

<A NAME="lbAN">&nbsp;</A>
<H2>日付時刻の設定</H2>



<A NAME="lbAO">&nbsp;</A>
<H3>外部同期なしの時刻の維持</H3>


<P>


この議論は以下の条件に基づいている:
<DL COMPACT>
<DT>&bull;<DD>

NTP デーモンや cron ジョブのように、日付時刻のクロックを変更するものが動作していない。
<DT>&bull;<DD>


システムのタイムゾーンが正しいローカル時刻に設定されていること。
以下の
<B>POSIX vs 「正しい」データベース</B>

を参照すること。
<DT>&bull;<DD>

起動時に以下の順番で呼ばれていること:
<BR>

<B>adjtimex&nbsp;--tick</B><I>&nbsp;value&nbsp;</I><B>--frequency</B><I>&nbsp;value</I>

<BR>

<B>hwclock&nbsp;--hctosys</B>

<DT>&bull;<DD>

シャットダウンで以下が呼ばれていること:
<BR>

<B>hwclock&nbsp;--systohc</B>

</DL>
<P>



<B>* adjtimex</B> がないシステムで <B>ntptime</B> を使うことができる。


<P>




NTP デーモンで正確な時間が維持されているか否かに関わらず、
システムが適切な日付時刻を維持できるように設定されていることには意味がある。
<P>










最初のステップは、概要を明確に理解することである。
2 つの完全に分離されたハードウェアデバイスがそれぞれの速さで動いており、
「正しい」時刻からそれぞれの割合でずれていく。
ずれの補正の方法とソフトウェアは、それぞれで異なる。
しかし、多くのシステムでは、2 つの時計が
起動時とシャットダウン時にそれぞれの値を交換するように設定されている。
今、各デバイスのエラーを含む時刻が相互にやりとりされている。
一方のデバイスについてのみ、ずれの補正が行われるように設定された場合、
他方のずれは一方の補正値で上書きされる。
<P>








この問題は、システム・クロックのずれ補正を設定するときに、
マシンをシャットダウンしないことで回避できる。
これにプラスして、(ずれ要素の計算を含む)
<B>hwclock</B>

の精度は、システム・クロックのずれの割合が修正されているかに依存する。
つまり、システム・クロックの設定は最初にすべきである。
<P>








システム・クロックのずれは、
<B><A HREF="../man8/adjtimex.8.html">adjtimex</A></B>(8) コマンドの <B>--tick</B> と <B>--frequency</B>

オプションで修正できる。
この 2 つのオプションは同時に動作させることができる:
tick は大まかな補正をし、frequency は細かな補正を行う。
(<B>adjtimex</B>

パッケージがないシステムでは、
<B>ntptime&nbsp;-f&nbsp;</B><I>ppm</I>

を代わりに使うことができる。)
<P>












Linux ディストリビューションの中には、システム・クロックのずれを
<B>adjtimex</B>

の比較操作で自動的に計算するものもある。
1 つのずれた時計を、もう1 つのずれた時計を参照して補正しようとした場合、
犬が自分の尻尾を噛もうとするようなものである。
最終的には成功するかもしれないが、多大な努力と不満が先立ってしまう。
この自動化は、改良して設定なしできるが、
期待される最適な結果はエラーになってしまう。
マニュアル設定のより良い選択肢は、
<B>adjtimex</B> の <B>--log </B>

オプションである。
<P>




より効率的な方法は、
<B>sntp</B> または <B>date&nbsp;-Ins</B>

によって単純にシステム・クロックのずれと正確な時間を追いかけ、
補正値を手動で計算する事である。
<P>






tick と frequency の値を設定した後、システム・クロックが適切な時間を維持できるまで、
テストと調整を続ける。
より詳細な情報と、手動でのずれの計算のデモンストレーションの例については、
<B><A HREF="../man8/adjtimex.8.html">adjtimex</A></B>(8)

を参照すること。
<P>


システム・クロックがなめらかに刻むようになったら、
ハードウェア・クロックに移る。
<P>






原則として、コールドなずれは、多くのユースケースで一番である。
通常のダウンタイムが再起動でのみ構成される 24/7 稼働するマシンでも、
これは真実である。
この場合、ずれ要素の値は少し異なる。
しかし、マシンのシャットダウンが伸びるまれなケースでは、
コールドなずれはより良い結果を生み出す。
<P>


<B>コールドなずれの計算ステップ:</B>

<DL COMPACT>
<DT>1<DD>

<B>NTP デーモンが起動時に開始されていないことを確認する。</B>

<DT>2<DD>

<I>システム・クロック</I>がシャットダウン時に正しくなっている必要がある!

<DT>3<DD>

システムをシャットダウンする。
<DT>4<DD>

ハードウェア・クロックを変更せず、拡張した期間 (extended period) をパスする。
<DT>5<DD>

システムを起動する。
<DT>6<DD>


すぐに
<B>hwclock</B>

を使って正確な時間を
<B>--update-drift</B>

を追加して設定する。
</DL>
<P>




注意: ステップ 6 で
<B>--systohc</B>

を使う場合、その前にシステム・クロックを
正しく設定しなければならない (ステップ 6a)。
<P>










<B>hwclock</B>

にずれ要素を計算させるのは、良いスタートポイントとなるが、
最適な値に調整するには、
<I>/etc/adjtime</I>

ファイルを直接編集する必要がある。
ハードウェア・クロックが起動時に完全正しくなるまで、ずれ要素を
テストして洗練させ続ける。
これをチェックするには、シャットダウンの前にシステム時刻が
正しくなっていることを確認し、次に起動直後に
<B>sntp</B> または <B>date&nbsp;-Ins</B>

と正確な時間を使う。

<A NAME="lbAP">&nbsp;</A>
<H3>ローカル時刻 vs UTC</H3>



ハードウェア・クロックをローカルタイムスケールで保持すると、
夏時間の結果に不整合を起こす。
<DL COMPACT>
<DT>&bull;<DD>


Linux が夏時間で動作していると、
ハードウェア・クロックにかかれた時刻は夏時間に調整される。
<DT>&bull;<DD>


Linux が夏時間で動作していないと、
ハードウェア・クロックにかかれた時刻は夏時間に調整されない。
</DL>
<P>






ISA 互換のシステムでは、ハードウェア・クロックは日付と時間しか保持せず、
タイムゾーンも夏時間という考え方もない。
よって、
<B>hwclock</B>

がローカル時刻であると言えば、それが「正しい」ローカル時間であると仮定し、
それから読み出す際に、何の調整も行わない。
<P>







Linux は、ハードウェア・クロックが UTC タイムスケールで保持されている場合にのみ、
透過的に夏時間への変更を行う。
システム管理者は簡単に
<B>hwclock</B>

を使ってローカル時刻を出力し、
<B>--date</B>

オプションの引き数に指定することができる。
<P>




Linux のような POSIX システムでは、
システム・クロックを UTC タイムスケールで扱うように設計されている。
ハードウェア・クロックの目的は、システム・クロックを初期化することなので、
時刻を UTC で保持することには意味がある。
<P>






一方で、Linux はハードウェア・クロックをローカルタイムスケールで提供しようとする。
これは、主に古いバージョンの MS Windows とのデュアルブートのためである。
WIndows 7 からは、正しく動作するように、
RealTimeIsUniversal レジストリキーがサポートされているので、
ハードウェア・クロックを UTC で保持することができる。

<A NAME="lbAQ">&nbsp;</A>
<H3>POSIX vs 「正しい」データベース</H3>






日付時刻の設定の議論は、タイムゾーンについて言及しないと不完全である。
タイムゾーンの言及は、
<B><A HREF="../man3/tzset.3.html">tzset</A></B>(3)

で大部分が充分にカバーされている。
ドキュメント化されていない 1 つの領域は、tz または zoneinfo とも呼ばれる、
タイムゾーンデータベースの「正しい」ディレクトリである。
<P>











zoneinfo システムには、posix データベースと「正しい」データベースの 2 つがある。
「正しい」データベース (ここでは閏秒付き zoneinfo と呼ぶデータベース) には、
閏秒が含まれるが、posix には含まれない。
「正しい」データベースを使うには、
システム・クロックを (UTC&nbsp;+&nbsp;閏秒) に設定しなければならない。
これは、(TAI&nbsp;-&nbsp;10) と同じである。
これにより、閏秒紀元年を考慮した 2 つの日付の間の、正確な秒数を計算できる。
システム・クロックは、閏秒を引いた「正しい」ゾーンファイルを使って、
UTC を含む正しい歴時間をカバーできるようになる。
注意: この設定は実験的と考えられており、問題があることも知られている。
<P>









システムが特定のデータベースを使うように設定するためには、
そのディレクトリにある全てのファイルが、
<I>/usr/share/zoneinfo</I>

をルートにしてにコピーされていなければならない。
ファイルは、例えば
TZ='<I>right/Europe/Dublin</I>'

のようにして、posix または「正しい」データベースの
サブディレクトリから直接使われることはない。
この方法はとても一般的になっており、上位の zoneinfo プロジェクトが、
posix または「正しい」データベースのサブディレクトリを
zoneinfo ディレクトリの外に出して、兄弟のディレクトリに入れることで、
システムのファイルツリーを再構成することができる。
<P>


<I>/usr/share/zoneinfo</I>

<BR>

<I>/usr/share/zoneinfo-posix</I>

<BR>

<I>/usr/share/zoneinfo-leaps</I>

<P>














不幸なことに、Linux ディストリビューションの中には、
パッケージ内で昔のツリー構造に戻しているものもある。
その場合、システム管理者が 'right' サブディレクトリに到達できる問題が残っている。
これは、システムのタイムゾーンが閏秒を含んでいるといるが、
zoneinfo データベースには閏秒が含んでいないという問題を引き起こす。
世界時計のようなアプリケーションが
South_Pole タイムゾーンファイルを必要とした場合や、
MTA に email を送る場合や、
<B>hwclock</B>

が UTC タイムゾーンファイルを必要とした場合、期待されているように、
ファイルを
<I>/usr/share/zoneinfo</I>

のルートから取得する必要がある。
これらのファイルには閏秒が含まれていないが、
システム・クロックは今日では閏秒を含んでいるので、
時刻の変換が不正になる。
<P>







これらの別々のデータベースを混ぜてファイルをマッチさせるのは、
それぞれがシステム・クロックで別々のタイムスケールを要求するので、
うまくいかない。
zoneinfo データベースは、上記で説明した
posix または「正しい」データベースのいずれかを使うか、
データベースのパスを
<FONT SIZE="-1"><B>TZDIR</B></FONT>
環境変数で指定しなければならない。

<A NAME="lbAR">&nbsp;</A>
<H2>返り値</H2>


以下の返り値の 1 つが返される:
<DL COMPACT>
<DT>
<DD>

<B>EXIT_SUCCESS</B> (POSIX システムでは '0')

プログラムの実行に成功した。
<DT>
<DD>

<B>EXIT_FAILURE</B> (POSIX システムでは '1')

操作に失敗した。または、コマンド書式が不正である。

</DL>
<A NAME="lbAS">&nbsp;</A>
<H2>環境変数</H2>

<DL COMPACT>
<DT><B>TZ</B>

<DD>


この変数が設定されると、システムのタイムゾーン設定より優先される。
<DT><B>TZDIR</B>

<DD>


この変数が設定されると、システムのタイムゾーンデータベースの
ディレクトリパスより優先される。

</DL>
<A NAME="lbAT">&nbsp;</A>
<H2>ファイル</H2>

<DL COMPACT>
<DT><I>/etc/adjtime</I>

<DD>

hwclock の設定と状態ファイル。
<DT><I>/etc/localtime</I>

<DD>

システムのタイムゾーンファイル。
<DT><I>/usr/share/zoneinfo/</I>

<DD>

システムのタイムゾーンデータベースのディレクトリ。
</DL>
<P>




<B>hwclock</B>

がハードウェア・クロックのアクセスに使うデバイスファイル:
<BR>

<I>/dev/rtc0</I>

<BR>

<I>/dev/rtc</I>

<BR>

<I>/dev/misc/rtc</I>

<BR>

<I>/dev/efirtc</I>

<BR>

<I>/dev/misc/efirtc</I>


<A NAME="lbAU">&nbsp;</A>
<H2>関連項目</H2>

<B><A HREF="../man1/date.1.html">date</A></B>(1),

<B><A HREF="../man8/adjtimex.8.html">adjtimex</A></B>(8),

<B><A HREF="../man2/gettimeofday.2.html">gettimeofday</A></B>(2),

<B><A HREF="../man2/settimeofday.2.html">settimeofday</A></B>(2),

<B><A HREF="../man1/crontab.1.html">crontab</A></B>(1),

<B><A HREF="../man3/tzset.3.html">tzset</A></B>(3)

<P>

<A NAME="lbAV">&nbsp;</A>
<H2>著者</H2>






<B>hwclock</B>

は 1996 年 9 月に Bryan Henderson (<A HREF="mailto:bryanh@giraffe-data.com">bryanh@giraffe-data.com</A>) が
<B><A HREF="../man8/clock.8.html">clock</A></B>(8)

をもとに書いた。
<B><A HREF="../man8/clock.8.html">clock</A></B>(8)

は Charles Hendrick, Rob Hooft, Haraid Koenig によって書かれた。
完全な履歴と謝辞はソースに書かれている。

<A NAME="lbAW">&nbsp;</A>
<H2>入手方法</H2>



hwclock コマンドは util-linux パッケージの一部であり、
<A HREF="https://www.kernel.org/pub/linux/utils/util-linux/">https://www.kernel.org/pub/linux/utils/util-linux/</A>
から入手できる。
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">名前</A><DD>
<DT><A HREF="#lbAC">書式</A><DD>
<DT><A HREF="#lbAD">説明</A><DD>
<DT><A HREF="#lbAE">機能</A><DD>
<DT><A HREF="#lbAF">オプション</A><DD>
<DT><A HREF="#lbAG">注意</A><DD>
<DL>
<DT><A HREF="#lbAH">Linux システムにおける時計</A><DD>
<DT><A HREF="#lbAI">ハードウェア・クロックへのアクセス方法</A><DD>
<DT><A HREF="#lbAJ">時刻合わせ機能</A><DD>
<DT><A HREF="#lbAK">adjtime ファイル</A><DD>
<DT><A HREF="#lbAL">カーネルによるハードウェア・クロックの自動合わせ</A><DD>
<DT><A HREF="#lbAM">ISA ハードウェア・クロックの「世紀値 (Century value)」</A><DD>
</DL>
<DT><A HREF="#lbAN">日付時刻の設定</A><DD>
<DL>
<DT><A HREF="#lbAO">外部同期なしの時刻の維持</A><DD>
<DT><A HREF="#lbAP">ローカル時刻 vs UTC</A><DD>
<DT><A HREF="#lbAQ">POSIX vs 「正しい」データベース</A><DD>
</DL>
<DT><A HREF="#lbAR">返り値</A><DD>
<DT><A HREF="#lbAS">環境変数</A><DD>
<DT><A HREF="#lbAT">ファイル</A><DD>
<DT><A HREF="#lbAU">関連項目</A><DD>
<DT><A HREF="#lbAV">著者</A><DD>
<DT><A HREF="#lbAW">入手方法</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:47:08 GMT, May 03, 2020
</BODY>
</HTML>

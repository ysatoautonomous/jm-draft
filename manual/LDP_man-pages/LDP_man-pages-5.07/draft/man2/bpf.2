.\" Copyright (C) 2015 Alexei Starovoitov <ast@kernel.org>
.\" and Copyright (C) 2015 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" Japanese Version Copyright (c) 2021 Yuichi SATO
.\" Translated Tue Jan  5 00:18:15 JST 2021
.\"         by Yuichi SATO <ysato444@ybb.ne.jp>
.\"
.TH BPF 2 2020-06-09 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O bpf \- perform a command on an extended BPF map or program
bpf \- 拡張 (extended) BPF マップまたはプログラム上で、コマンドを実行する
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <linux/bpf.h>

.BI "int bpf(int " cmd ", union bpf_attr *" attr ", unsigned int " size );
.fi
.\"O .SH DESCRIPTION
.SH 説明
.\"O The
.\"O .BR bpf ()
.\"O system call performs a range of operations related to extended
.\"O Berkeley Packet Filters.
.BR bpf ()
システムコールは、extended Berkeley Packet Filters に関連する
さまざまな操作を実行する。
.\"O Extended BPF (or eBPF) is similar to
.\"O the original ("classic") BPF (cBPF) used to filter network packets.
extended BPF (または eBPF) は、
元々の ("classic") BPF (cBPF) と同じく、
ネットワークパケットをフィルタするために使われる。
.\"O For both cBPF and eBPF programs,
.\"O the kernel statically analyzes the programs before loading them,
.\"O in order to ensure that they cannot harm the running system.
cBPF と eBPF のプログラムの両方に対して、
カーネルはプログラムをロードする前に統計的に解析し、
プログラムが実行中のシステムを害することできないように保証する。
.PP
.\"O eBPF extends cBPF in multiple ways, including the ability to call
.\"O a fixed set of in-kernel helper functions
.\"O .\" See 'enum bpf_func_id' in include/uapi/linux/bpf.h
.\"O (via the
.\"O .B BPF_CALL
.\"O opcode extension provided by eBPF)
.\"O and access shared data structures such as eBPF maps.
eBPF は cBPF をいろいろな方法で拡張しており、
(eBPF で提供される
.B BPF_CALL
オペコード拡張を使って)
カーネル内ヘルパー関数のセットを呼び出したり、
eBPF マップのような共有データ構造体にアクセスできたりする。
.\"
.\"O .SS Extended BPF Design/Architecture
.SS extended BPF のデザイン/アーキテクチャ
.\"O eBPF maps are a generic data structure for storage of different data types.
eBPF マップは、さまざまなデータ型を格納するための、基本的なデータ構造体である。
.\"O Data types are generally treated as binary blobs, so a user just specifies
.\"O the size of the key and the size of the value at map-creation time.
データ型は、一般的にバイナリ blob として扱われるので、
ユーザはマップの作成時にキーのサイズと値のサイズを指定するだけでよい。
.\"O In other words, a key/value for a given map can have an arbitrary structure.
言い換えれば、指定されたマップのキー/値には、任意の構造体を含めることが
できる。
.PP
.\"O A user process can create multiple maps (with key/value-pairs being
.\"O opaque bytes of data) and access them via file descriptors.
ユーザプロセスは (データのバイト数が不定なキー/値のペアを持つ) 複数のマップを作成し、
ファイルディスクリプターを使ってマップにアクセスできる。
.\"O Different eBPF programs can access the same maps in parallel.
異なる eBPF プログラムが、同じマップに同時並行にアクセスできる。
.\"O It's up to the user process and eBPF program to decide what they store
.\"O inside maps.
マップの中に何を格納するかは、ユーザプロセスと eBPF プログラムが決定できる。
.PP
.\"O There's one special map type, called a program array.
プログラム配列と呼ばれる特別なマップ型がある。
.\"O This type of map stores file descriptors referring to other eBPF programs.
この型のマップは、他の eBPF プログラムを参照するファイルディスクリプターを格納する。
.\"O When a lookup in the map is performed, the program flow is
.\"O redirected in-place to the beginning of another eBPF program and does not
.\"O return back to the calling program.
マップの参照が行われると、プログラムフローが
その場で他の eBPF プログラムの最初にリダイレクトされ、
呼び出したプログラムには戻らない。
.\"O The level of nesting has a fixed limit of 32,
.\"O .\" Defined by the kernel constant MAX_TAIL_CALL_CNT in include/linux/bpf.h
.\"O so that infinite loops cannot be crafted.
入れ子のレベルは 32 に制限されているので、
無限ループは作れない。
.\"O At run time, the program file descriptors stored in the map can be modified,
.\"O so program functionality can be altered based on specific requirements.
マップに格納されたファイルディスクリプターは、実行時に変更できるので、
プログラムの機能は、特定の要件に基づいて変更できる。
.\"O All programs referred to in a program-array map must
.\"O have been previously loaded into the kernel via
.\"O .BR bpf ().
プログラム配列マップで参照されるすべてのプログラムは、
.BR bpf ()
で前もってカーネルにロードされていなればならない。
.\"O If a map lookup fails, the current program continues its execution.
マップの参照が失敗した場合、現在のプログラムが実行を継続する。
.\"O See
.\"O .B BPF_MAP_TYPE_PROG_ARRAY
.\"O below for further details.
より詳細は、下記の
.B BPF_MAP_TYPE_PROG_ARRAY
を参照すること。
.PP
.\"O Generally, eBPF programs are loaded by the user process and automatically
.\"O unloaded when the process exits.
一般的には、eBPF プログラムはユーザプロセスによってロードされ、
プロセスが終了すると自動的にアンロードされる。
.\"O In some cases, for example,
.\"O .BR tc-bpf (8),
.\"O the program will continue to stay alive inside the kernel even after the
.\"O process that loaded the program exits.
いくつかの場合、例えば
.BR tc-bpf (8)
では、プログラムをロードしたプロセスが終了した後でも、
プログラムをカーネル内部に生かし続けることができる。
.\"O In that case,
.\"O the tc subsystem holds a reference to the eBPF program after the
.\"O file descriptor has been closed by the user-space program.
この場合、ファイルディスクリプターがユーザ空間プログラムによって
クローズされた後も、tc サブシステムが eBPF プログラムの参照を持ちづづける。
.\"O Thus, whether a specific program continues to live inside the kernel
.\"O depends on how it is further attached to a given kernel subsystem
.\"O after it was loaded via
.\"O .BR bpf ().
よって、特定のプログラムをカーネル内部で生かし続けるか否かは、
.BR bpf ()
でロードされた後に、指定されたカーネルサブシステムにどのように
アタッチされるかに依存する。
.PP
.\"O Each eBPF program is a set of instructions that is safe to run until
.\"O its completion.
各 eBPF プログラムは、命令 (instruction) の集合であり、
その命令は完了まで安全に実行することができる。
.\"O An in-kernel verifier statically determines that the eBPF program
.\"O terminates and is safe to execute.
カーネル内の検証器 (verifier) は、eBPF プログラムが終了するかと、
安全に実行できるかを、統計的に決定する。
.\"O During verification, the kernel increments reference counts for each of
.\"O the maps that the eBPF program uses,
.\"O so that the attached maps can't be removed until the program is unloaded.
検証の過程で、カーネルは eBPF プログラムが使う各マップの参照カウントを増やすので、
アタッチされたマップは、プログラムがアンロードされるまで削除されない。
.PP
.\"O eBPF programs can be attached to different events.
eBPF プログラムは、さまざまなイベントにアタッチすることができる。
.\"O These events can be the arrival of network packets, tracing
.\"O events, classification events by network queueing  disciplines
.\"O (for eBPF programs attached to a
.\"O .BR tc (8)
.\"O classifier), and other types that may be added in the future.
これらのイベントには、ネットワークパケットの到達、追跡 (tracing) イベント、
.RB ( tc (8)
classifier にアタッチされた eBPF プログラムについての)
ネットワーク待ちの規則 (queueing discipline) による分類イベント、
将来追加される可能性のある他のタイプのイベントがある。
.\"O A new event triggers execution of the eBPF program, which
.\"O may store information about the event in eBPF maps.
新しいイベントが起きると、eBPF マップにそのイベントについての情報を格納している、
eBPF マップが実行される。
.\"O Beyond storing data, eBPF programs may call a fixed set of
.\"O in-kernel helper functions.
eBPF プログラムは、データを格納するだけでなく、
固定のカーネルヘルパー関数のセットを呼び出すことができる。
.PP
.\"O The same eBPF program can be attached to multiple events and different
.\"O eBPF programs can access the same map:
eBPF プログラムを複数のイベントにアタッチでき、
複数の eBPF プログラムから同じマップにアクセスできる。
.PP
.in +4n
.EX
tracing     tracing    tracing    packet      packet     packet
event A     event B    event C    on eth0     on eth1    on eth2
 |             |         |          |           |          ^
 |             |         |          |           v          |
 --> tracing <--     tracing      socket    tc ingress   tc egress
      prog_1          prog_2      prog_3    classifier    action
      |  |              |           |         prog_4      prog_5
   |---  -----|  |------|          map_3        |           |
 map_1       map_2                              --| map_4 |--
.EE
.in
.\"
.\"O .SS Arguments
.SS 引き数
.\"O The operation to be performed by the
.\"O .BR bpf ()
.\"O system call is determined by the
.\"O .I cmd
.\"O argument.
.BR bpf ()
システムコールで実行される操作は、
.I cmd
引き数で決定される。
.\"O Each operation takes an accompanying argument,
.\"O provided via
.\"O .IR attr ,
.\"O which is a pointer to a union of type
.\"O .I bpf_attr
.\"O (see below).
各操作は、
.I attr
で与えられる付随する引き数をとる。
.I attr
は
.I bpf_attr
型の共用体 (union) へのポインタである (下記参照)。
.\"O The
.\"O .I size
.\"O argument is the size of the union pointed to by
.\"O .IR attr .
.I size
引き数は、
.I attr
で指される共用体のサイズである。
.PP
.\"O The value provided in
.\"O .I cmd
.\"O is one of the following:
.I cmd
に指定可能な値は、以下のいずれかである:
.TP
.B BPF_MAP_CREATE
.\"O Create a map and return a file descriptor that refers to the map.
マップを作成し、マップを参照するファイルディスクリプターを返す。
.\"O The close-on-exec file descriptor flag (see
.\"O .BR fcntl (2))
.\"O is automatically enabled for the new file descriptor.
新しいファイルディスクリプターについては、
close-on-exec ファイルディスクリプターフラグ
.RB ( fcntl (2)
を参照) が自動的に有効にされる。
.TP
.B BPF_MAP_LOOKUP_ELEM
.\"O Look up an element by key in a specified map and return its value.
指定されたマップでキーで要素を探し、その値を返す。
.TP
.B BPF_MAP_UPDATE_ELEM
.\"O Create or update an element (key/value pair) in a specified map.
指定されたマップで要素 (キー/値のペア) を作成または更新する。
.TP
.B BPF_MAP_DELETE_ELEM
.\"O Look up and delete an element by key in a specified map.
指定されたマップでキーで要素を探し、削除する。
.TP
.B BPF_MAP_GET_NEXT_KEY
.\"O Look up an element by key in a specified map and return the key
.\"O of the next element.
指定されたマップでキーで要素を探し、次の要素のキーを返す。
.TP
.B BPF_PROG_LOAD
.\"O Verify and load an eBPF program,
.\"O returning a new file descriptor associated with the program.
eBPF プログラムを検証してロードし、
プログラムに紐づけられた新しいファイルディスクリプターを返す。
.\"O The close-on-exec file descriptor flag (see
.\"O .BR fcntl (2))
.\"O is automatically enabled for the new file descriptor.
close-on-exec ファイルディスクリプターフラグ
.RB ( fcntl (2)
を参照) が自動的に有効にされる。
.IP
.\"O The
.\"O .I bpf_attr
.\"O union consists of various anonymous structures that are used by different
.\"O .BR bpf ()
.\"O commands:
.I bpf_attr
共用体は、
いろいろな
.BR bpf ()
コマンドで使われるさまざまな無名 (anonymous) の構造体から構成される :
.PP
.in +4n
.EX
union bpf_attr {
    struct {    /* Used by BPF_MAP_CREATE */
        __u32         map_type;
        __u32         key_size;    /* size of key in bytes */
        __u32         value_size;  /* size of value in bytes */
        __u32         max_entries; /* maximum number of entries
                                      in a map */
    };

    struct {    /* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY
                   commands */
        __u32         map_fd;
        __aligned_u64 key;
        union {
            __aligned_u64 value;
            __aligned_u64 next_key;
        };
        __u64         flags;
    };

    struct {    /* Used by BPF_PROG_LOAD */
        __u32         prog_type;
        __u32         insn_cnt;
        __aligned_u64 insns;      /* 'const struct bpf_insn *' */
        __aligned_u64 license;    /* 'const char *' */
        __u32         log_level;  /* verbosity level of verifier */
        __u32         log_size;   /* size of user buffer */
        __aligned_u64 log_buf;    /* user supplied 'char *'
                                     buffer */
        __u32         kern_version;
                                  /* checked when prog_type=kprobe
                                     (since Linux 4.1) */
.\"                 commit 2541517c32be2531e0da59dfd7efc1ce844644f5
    };
} __attribute__((aligned(8)));
.EE
.in
.\"
.\"O .SS eBPF maps
.SS eBPF マップ
.\"O Maps are a generic data structure for storage of different types of data.
マップは、いろいろタイプのデータを格納するための、基本的な
データ構造である。
.\"O They allow sharing of data between eBPF kernel programs,
.\"O and also between kernel and user-space applications.
マップによって、eBPF カーネルプログラム間でデータを共有したり、
カーネルとユーザ空間アプリケーションでデータを共有したりできる。
.PP
.\"O Each map type has the following attributes:
各マップタイプには以下の属性がある:
.IP * 3
.\"O type
型
.IP *
.\"O maximum number of elements
最大の要素数
.IP *
.\"O key size in bytes
キーのサイズ (バイト単位)
.IP *
.\"O value size in bytes
値のサイズ (バイト単位)
.PP
.\"O The following wrapper functions demonstrate how various
.\"O .BR bpf ()
.\"O commands can be used to access the maps.
以下のラッパー関数は、さまざまな
.BR bpf ()
コマンドが、どのようにマップへのアクセスに使えるかを示している。
.\"O The functions use the
.\"O .I cmd
.\"O argument to invoke different operations.
これらの関数は、
.I cmd
引き数を使って、別々の操作を呼び出している。
.TP
.B BPF_MAP_CREATE
.\"O The
.\"O .B BPF_MAP_CREATE
.\"O command creates a new map,
.\"O returning a new file descriptor that refers to the map.
.B BPF_MAP_CREATE
コマンドは新しいマップを作成し、
そのマップを参照する新しいファイルディスクリプターを返す。
.IP
.in +4n
.EX
int
bpf_create_map(enum bpf_map_type map_type,
               unsigned int key_size,
               unsigned int value_size,
               unsigned int max_entries)
{
    union bpf_attr attr = {
        .map_type    = map_type,
        .key_size    = key_size,
        .value_size  = value_size,
        .max_entries = max_entries
    };

    return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));
}
.EE
.in
.IP
.\"O The new map has the type specified by
.\"O .IR map_type ,
.\"O and attributes as specified in
.\"O .IR key_size ,
.\"O .IR value_size ,
.\"O and
.\"O .IR max_entries .
新しいマップは
.I map_type
で指定された型で、
.IR key_size ,
.IR value_size ,
.I max_entries
で指定された属性を持つ。
.\"O On success, this operation returns a file descriptor.
成功した場合、この操作はファイルディスクリプターを返す。
.\"O On error, \-1 is returned and
.\"O .I errno
.\"O is set to
.\"O .BR EINVAL ,
.\"O .BR EPERM ,
.\"O or
.\"O .BR ENOMEM .
エラーの場合、\-1 が返され、
.I errno
に
.BR EINVAL ,
.BR EPERM ,
.B ENOMEM
のいずれかが設定される。
.IP
.\"O The
.\"O .I key_size
.\"O and
.\"O .I value_size
.\"O attributes will be used by the verifier during program loading
.\"O to check that the program is calling
.\"O .BR bpf_map_*_elem ()
.\"O helper functions with a correctly initialized
.\"O .I key
.\"O and to check that the program doesn't access the map element
.\"O .I value
.\"O beyond the specified
.\"O .IR value_size .
.I key_size
と
.I value_size
属性は、プログラムのロード時に検証器が使用し、プログラムが、
正しく初期化された
.I key
で
.BR bpf_map_*_elem ()
ヘルパー関数を呼び出しているかのチェックと、
.I value_size
で指定された範囲を超えてマップ要素
.I value
にアクセスしていないかのチェックを行う。
.\"O For example, when a map is created with a
.\"O .I key_size
.\"O of 8 and the eBPF program calls
例えば、
.I key_size
を 8 としてマップが作成されて、eBPF プログラムが
.IP
.in +4n
.EX
bpf_map_lookup_elem(map_fd, fp - 4)
.EE
.in
.IP
.\"O the program will be rejected,
.\"O since the in-kernel helper function
を呼び出した場合、プログラムは拒否される。
なぜなら、カーネル内のヘルパー関数
.IP
.EX
    bpf_map_lookup_elem(map_fd, void *key)
.EE
.IP
.\"O expects to read 8 bytes from the location pointed to by
.\"O .IR key ,
.\"O but the
.\"O .I fp\ -\ 4
.\"O (where
.\"O .I fp
.\"O is the top of the stack)
.\"O starting address will cause out-of-bounds stack access.
は、
.I key
で指される位置から、8 バイトを読み込むことを想定しているが、
開始アドレス
.I fp\ -\ 4
(ここで
.I fp
はスタックのトップ) は、範囲外のスタックアスクセスを起こしてしまうからである。
.IP
.\"O Similarly, when a map is created with a
.\"O .I value_size
.\"O of 1 and the eBPF program contains
同様に、
.I value_size
を 1 としてマップが作成された場合、eBPF プログラムに
.IP
.in +4n
.EX
value = bpf_map_lookup_elem(...);
*(u32 *) value = 1;
.EE
.in
.IP
.\"O the program will be rejected, since it accesses the
.\"O .I value
.\"O pointer beyond the specified 1 byte
.\"O .I value_size
.\"O limit.
というコードが含まれていた場合、プログラムは拒否される。
なぜなら、
.I value
ポインターが指定した 1 バイトの
.I value_size
の制限を越えてしまうからである。
.IP
.\"O Currently, the following values are supported for
.\"O .IR map_type :
現在のところ、
.I map_type
として以下の値がサポートされている:
.IP
.in +4n
.EX
enum bpf_map_type {
    BPF_MAP_TYPE_UNSPEC,  /* Reserve 0 as invalid map type */
    BPF_MAP_TYPE_HASH,
    BPF_MAP_TYPE_ARRAY,
    BPF_MAP_TYPE_PROG_ARRAY,
    BPF_MAP_TYPE_PERF_EVENT_ARRAY,
    BPF_MAP_TYPE_PERCPU_HASH,
    BPF_MAP_TYPE_PERCPU_ARRAY,
    BPF_MAP_TYPE_STACK_TRACE,
    BPF_MAP_TYPE_CGROUP_ARRAY,
    BPF_MAP_TYPE_LRU_HASH,
    BPF_MAP_TYPE_LRU_PERCPU_HASH,
    BPF_MAP_TYPE_LPM_TRIE,
    BPF_MAP_TYPE_ARRAY_OF_MAPS,
    BPF_MAP_TYPE_HASH_OF_MAPS,
    BPF_MAP_TYPE_DEVMAP,
    BPF_MAP_TYPE_SOCKMAP,
    BPF_MAP_TYPE_CPUMAP,
    BPF_MAP_TYPE_XSKMAP,
    BPF_MAP_TYPE_SOCKHASH,
    BPF_MAP_TYPE_CGROUP_STORAGE,
    BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,
    BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,
    BPF_MAP_TYPE_QUEUE,
    BPF_MAP_TYPE_STACK,
    /* See /usr/include/linux/bpf.h for the full list. */
};
.EE
.in
.IP
.\"O .I map_type
.\"O selects one of the available map implementations in the kernel.
.I map_type
として、カーネルでの利用可能なマップ実装の 1 つを選択する。
.\" FIXME We need an explanation of why one might choose each of
.\" these map implementations
.\"O For all map types,
.\"O eBPF programs access maps with the same
.\"O .BR bpf_map_lookup_elem ()
.\"O and
.\"O .BR bpf_map_update_elem ()
.\"O helper functions.
すべてのマップ型について、eBPF プログラムは
.BR bpf_map_lookup_elem ()
と
.BR bpf_map_update_elem ()
ヘルパー関数でマップにアクセスできる。
.\"O Further details of the various map types are given below.
いろいろなマップ型のより詳細については、下記を参照すること。
.TP
.B BPF_MAP_LOOKUP_ELEM
.\"O The
.\"O .B BPF_MAP_LOOKUP_ELEM
.\"O command looks up an element with a given
.\"O .I key
.\"O in the map referred to by the file descriptor
.\"O .IR fd .
.B BPF_MAP_LOOKUP_ELEM
コマンドは、ファイルディスクリプター
.I fd
で参照されるマップから、指定された
.I key
で要素を検索する。
.IP
.in +4n
.EX
int
bpf_lookup_elem(int fd, const void *key, void *value)
{
    union bpf_attr attr = {
        .map_fd = fd,
        .key    = ptr_to_u64(key),
        .value  = ptr_to_u64(value),
    };

    return bpf(BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
}
.EE
.in
.IP
.\"O If an element is found,
.\"O the operation returns zero and stores the element's value into
.\"O .IR value ,
.\"O which must point to a buffer of
.\"O .I value_size
.\"O bytes.
要素が見つかった場合、この操作では 0 が返され、要素の値が
.I value
に格納される。
.I value
は
.I value_size
バイトのバッファを指していなければならない。
.IP
.\"O If no element is found, the operation returns \-1 and sets
.\"O .I errno
.\"O to
.\"O .BR ENOENT .
要素が見つからない場合、この操作では \-1 が返され、
.I errno
が
.B ENOENT
に設定される。
.TP
.B BPF_MAP_UPDATE_ELEM
.\"O The
.\"O .B BPF_MAP_UPDATE_ELEM
.\"O command
.\"O creates or updates an element with a given
.\"O .I key/value
.\"O in the map referred to by the file descriptor
.\"O .IR fd .
.B BPF_MAP_UPDATE_ELEM
コマンドは、ファイルディスクリプター
.I fd
で参照されるマップに、指定した
.I key/value
の要素を作成または更新する。
.IP
.in +4n
.EX
int
bpf_update_elem(int fd, const void *key, const void *value,
                uint64_t flags)
{
    union bpf_attr attr = {
        .map_fd = fd,
        .key    = ptr_to_u64(key),
        .value  = ptr_to_u64(value),
        .flags  = flags,
    };

    return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}
.EE
.in
.IP
.\"O The
.\"O .I flags
.\"O argument should be specified as one of the following:
.I flags
引き数は、以下のうち 1 つを指定しなければならない:
.RS
.TP
.B BPF_ANY
.\"O Create a new element or update an existing element.
新しい要素を作成するか、既存の要素を更新する。
.TP
.B BPF_NOEXIST
.\"O Create a new element only if it did not exist.
指定した要素が存在しない場合にのみ、新しい要素として
作成する。
.TP
.B BPF_EXIST
.\"O Update an existing element.
既存の要素を更新する。
.RE
.IP
.\"O On success, the operation returns zero.
成功した場合、この操作は 0 を返す。
.\"O On error, \-1 is returned and
.\"O .I errno
.\"O is set to
.\"O .BR EINVAL ,
.\"O .BR EPERM ,
.\"O .BR ENOMEM ,
.\"O or
.\"O .BR E2BIG .
エラーの場合、\-1 が返され、
.I errno
が
.BR EINVAL ,
.BR EPERM ,
.BR ENOMEM ,
.B E2BIG
のいずれかに設定される。
.\"O .B E2BIG
.\"O indicates that the number of elements in the map reached the
.\"O .I max_entries
.\"O limit specified at map creation time.
.B E2BIG
はマップの要素数が、マップの作成時に指定した
.I max_entries
の制限に達したことを表す。
.\"O .B EEXIST
.\"O will be returned if
.\"O .I flags
.\"O specifies
.\"O .B BPF_NOEXIST
.\"O and the element with
.\"O .I key
.\"O already exists in the map.
.B EEXIST
は、
.I flags
に
.B BPF_NOEXIST
が指定されていて、かつマップに
.I key
の要素が既に存在する場合に返される。
.\"O .B ENOENT
.\"O will be returned if
.\"O .I flags
.\"O specifies
.\"O .B BPF_EXIST
.\"O and the element with
.\"O .I key
.\"O doesn't exist in the map.
.B ENOENT
は、
.I flags
に
.B BPF_EXIST
が指定されていて、かつマップに
.I key
の要素が存在しない場合に返される。
.TP
.B BPF_MAP_DELETE_ELEM
.\"O The
.\"O .B BPF_MAP_DELETE_ELEM
.\"O command
.\"O deletes the element whose key is
.\"O .I key
.\"O from the map referred to by the file descriptor
.\"O .IR fd .
.B BPF_MAP_DELETE_ELEM
コマンドは、ファイルディスクリプター
.I fd
で参照されるマップから、キーが
.I key
の要素を削除する。
.IP
.in +4n
.EX
int
bpf_delete_elem(int fd, const void *key)
{
    union bpf_attr attr = {
        .map_fd = fd,
        .key    = ptr_to_u64(key),
    };

    return bpf(BPF_MAP_DELETE_ELEM, &attr, sizeof(attr));
}
.EE
.in
.IP
.\"O On success, zero is returned.
成功した場合、0 が返される。
.\"O If the element is not found, \-1 is returned and
.\"O .I errno
.\"O is set to
.\"O .BR ENOENT .
要素が見つからない場合、\-1 が返され、
.I errno
が
.B ENOENT
に設定される。
.TP
.B BPF_MAP_GET_NEXT_KEY
.\"O The
.\"O .B BPF_MAP_GET_NEXT_KEY
.\"O command looks up an element by
.\"O .I key
.\"O in the map referred to by the file descriptor
.\"O .I fd
.\"O and sets the
.\"O .I next_key
.\"O pointer to the key of the next element.
.B BPF_MAP_GET_NEXT_KEY
コマンドは、ファイルディスクリプター
.I fd
で参照されるマップから
.I key
で要素を検索し、次の要素のキーを
.I next_key
ポインタに設定する。
.IP
.in +4n
.EX
int
bpf_get_next_key(int fd, const void *key, void *next_key)
{
    union bpf_attr attr = {
        .map_fd   = fd,
        .key      = ptr_to_u64(key),
        .next_key = ptr_to_u64(next_key),
    };

    return bpf(BPF_MAP_GET_NEXT_KEY, &attr, sizeof(attr));
}
.EE
.in
.IP
.\"O If
.\"O .I key
.\"O is found, the operation returns zero and sets the
.\"O .I next_key
.\"O pointer to the key of the next element.
.I key
が見つかった場合、この操作は 0 を返し、次の要素のキーが
.I next_key
ポインタに設定される。
.\"O If
.\"O .I key
.\"O is not found, the operation returns zero and sets the
.\"O .I next_key
.\"O pointer to the key of the first element.
.I key
が見つからなかった場合、この操作は 0 を返し、最初の要素のキーが
.I next_key
ポインタに設定される。
.\"O If
.\"O .I key
.\"O is the last element, \-1 is returned and
.\"O .I errno
.\"O is set to
.\"O .BR ENOENT .
.I key
が最後の要素の場合、\-1 が返され、
.I errno
が
.B ENOENT
に設定される。
.\"O Other possible
.\"O .I errno
.\"O values are
.\"O .BR ENOMEM ,
.\"O .BR EFAULT ,
.\"O .BR EPERM ,
.\"O and
.\"O .BR EINVAL .
その他に
.I errno
に設定される可能性のある値は、
.BR ENOMEM ,
.BR EFAULT ,
.BR EPERM ,
.B EINVAL
である。
.\"O This method can be used to iterate over all elements in the map.
このメソッドは、マップのすべての要素を辿るために使われる。
.TP
.B close(map_fd)
.\"O Delete the map referred to by the file descriptor
.\"O .IR map_fd .
ファイルディスクリプター
.I map_fd
で参照されるマップを削除する。
.\"O When the user-space program that created a map exits, all maps will
.\"O be deleted automatically (but see NOTES).
マップを作成したユーザ空間プログラムが存在する場合、
すべてのマップは自動的に削除される (「注意」を参照すること)。
.\"
.\"O .SS eBPF map types
.SS eBPF マップ型
.\"O The following map types are supported:
以下のマップ型がサポートされる:
.TP
.B BPF_MAP_TYPE_HASH
.\" commit 0f8e4bd8a1fc8c4185f1630061d0a1f2d197a475
.\"O Hash-table maps have the following characteristics:
ハッシュテーブルマップには、以下の特徴がある。
.RS
.IP * 3
.\"O Maps are created and destroyed by user-space programs.
マップはユーザ空間プログラムによって、作成または破壊される。
.\"O Both user-space and eBPF programs
.\"O can perform lookup, update, and delete operations.
ユーザ空間プログラムと eBPF プログラムの両方が、
検索、更新、削除の操作を行える。
.IP *
.\"O The kernel takes care of allocating and freeing key/value pairs.
カーネルがキー/値のペアの確保と解放に責任を持つ。
.IP *
.\"O The
.\"O .BR map_update_elem ()
.\"O helper will fail to insert new element when the
.\"O .I max_entries
.\"O limit is reached.
.BR map_update_elem ()
ヘルパーは、
.I max_entries
の制限に到達した場合、新しい要素の挿入に失敗する。
.\"O (This ensures that eBPF programs cannot exhaust memory.)
(これにより、eBPF プログラムがメモリを使い果たさないようにできる。)
.IP *
.\"O .BR map_update_elem ()
.\"O replaces existing elements atomically.
.BR map_update_elem ()
は、既存の要素を自動的に置き換える。
.RE
.IP
.\"O Hash-table maps are
.\"O optimized for speed of lookup.
ハッシュテーブルマップは、検索の速度に最適化されている。
.TP
.B BPF_MAP_TYPE_ARRAY
.\" commit 28fbcfa08d8ed7c5a50d41a0433aad222835e8e3
.\"O Array maps have the following characteristics:
配列マップには、以下の特徴がある。
.RS
.IP * 3
.\"O Optimized for fastest possible lookup.
検索を最速にするために最適化されている。
.\"O In the future the verifier/JIT compiler
.\"O may recognize lookup() operations that employ a constant key
.\"O and optimize it into constant pointer.
将来的に、検証器と JIT コンパイラーは、
固定のキーが使われている lookup() 操作を認識し、
固定のポインタに最適化できるかもしれない。
.\"O It is possible to optimize a non-constant
.\"O key into direct pointer arithmetic as well, since pointers and
.\"O .I value_size
.\"O are constant for the life of the eBPF program.
eBPF プログラムの生存期間中、
ポインタと
.I value_size
は一定であるので、固定でないキーでも、直接のポインタ計算に
最適化できる。
.\"O In other words,
.\"O .BR array_map_lookup_elem ()
.\"O may be 'inlined' by the verifier/JIT compiler
.\"O while preserving concurrent access to this map from user space.
言い換えると、
.BR array_map_lookup_elem ()
は、ユーザ空間からの並行アクセスを保持しながら、
検証器と JIT コンパイラによって「インライン」にできる。
.IP *
.\"O All array elements pre-allocated and zero initialized at init time
すべての配列要素はあらかじめ確保され、最初に 0 で初期化される。
.IP *
.\"O The key is an array index, and must be exactly four bytes.
キーは配列のインデックスであり、必ず 4 バイトでなければならない。
.IP *
.\"O .BR map_delete_elem ()
.\"O fails with the error
.\"O .BR EINVAL ,
.\"O since elements cannot be deleted.
.BR map_delete_elem ()
は、要素が削除できないので、エラー
.B EINVAL
で失敗する。
.IP *
.\"O .BR map_update_elem ()
.\"O replaces elements in a
.\"O .B nonatomic
.\"O fashion;
.\"O for atomic updates, a hash-table map should be used instead.
.BR map_update_elem ()
は要素を
.B アトミックでない
やり方で置き換える。
アトミックな更新をするためには、ハッシュテーブルマップを
使うべきである。
.\"O There is however one special case that can also be used with arrays:
しかし、特別な場合には、(アトミックな更新に) 配列を使うことができる:
.\"O the atomic built-in
.\"O .B __sync_fetch_and_add()
.\"O can be used on 32 and 64 bit atomic counters.
アトミックな組み込みの
.B __sync_fetch_and_add()
は 32 ビットと 64 ビットのアトミックなカウンターで使うことができる。
.\"O For example, it can be
.\"O applied on the whole value itself if it represents a single counter,
.\"O or in case of a structure containing multiple counters, it could be
.\"O used on individual counters.
例えば、この関数は、値が 1 つのカウンターである場合、値全体に適用することができる。
また、この関数は、構造体が複数のカウンターを含んでいる場合、
個々のカウンターに使うことができる。
.\"O This is quite often useful for aggregation and accounting of events.
これは、しばしばイベントの集約や集計にとても役立つ。
.RE
.IP
.\"O Among the uses for array maps are the following:
配列マップの使い方は、以下の通りである:
.RS
.IP * 3
.\"O As "global" eBPF variables: an array of 1 element whose key is (index) 0
.\"O and where the value is a collection of 'global' variables which
.\"O eBPF programs can use to keep state between events.
「グローバルな」eBPF 変数として:要素が 1 の配列で、キーを (インデックス) 0 とする。
ここで値は、「グローバルな」変数の集合であり、
eBPF プログラムはイベント間で状態を保持するのに使う。
.IP *
.\"O Aggregation of tracing events into a fixed set of buckets.
.\": 
.\": この翻訳は自信なし
.\": 
トレーシングイベントを、バケットの固定の集合に集約する。
.IP *
.\"O Accounting of networking events, for example, number of packets and packet
.\"O sizes.
ネットワーキングイベント、例えば、パケット数または
パケットサイズを集計する。
.RE
.TP
.\"O .BR BPF_MAP_TYPE_PROG_ARRAY " (since Linux 4.2)"
.BR BPF_MAP_TYPE_PROG_ARRAY " (Linux 4.2 以降)"
.\"O A program array map is a special kind of array map whose map values
.\"O contain only file descriptors referring to other eBPF programs.
プログラム配列マップは、配列マップの特別な形式であり、
マップの値は、他の eBPF プログラムを参照するファイルディスクリプターのみを保持する。
.\"O Thus, both the
.\"O .I key_size
.\"O and
.\"O .I value_size
.\"O must be exactly four bytes.
よって、
.I key_size
と
.I value_size
は、必ず 4 バイトでなければならない。
.\"O This map is used in conjunction with the
.\"O .BR bpf_tail_call ()
.\"O helper.
このマップは、
.BR bpf_tail_call ()
ヘルパーと併せて使われる。
.IP
.\"O This means that an eBPF program with a program array map attached to it
.\"O can call from kernel side into
これは、プログラム配列マップをつけた eBPF プログラムは、
カーネルサイドから以下のように呼び出すことができるということである。
.IP
.in +4n
.EX
void bpf_tail_call(void *context, void *prog_map,
                   unsigned int index);
.EE
.in
.IP
.\"O and therefore replace its own program flow with the one from the program
.\"O at the given program array slot, if present.
そして、自身のプログラムフローを、指定したプログラム配列の
スロットにプログラムがあれば、それに置き換えることができる。
.\"O This can be regarded as kind of a jump table to a different eBPF program.
これは、別の eBPF プログラムへのジャンプテーブルの一種として扱うことができる。
.\"O The invoked program will then reuse the same stack.
そして、起動されたプログラムは、同じスタックを再利用する。
.\"O When a jump into the new program has been performed,
.\"O it won't return to the old program anymore.
新しいプログラムへのジャンプが実行された場合、前のプログラムには
戻らない。
.IP
.\"O If no eBPF program is found at the given index of the program array
.\"O (because the map slot doesn't contain a valid program file descriptor,
.\"O the specified lookup index/key is out of bounds,
.\"O or the limit of 32
.\"O .\" MAX_TAIL_CALL_CNT
.\"O nested calls has been exceed),
.\"O execution continues with the current eBPF program.
プログラム配列の指定されたインデックスに eBPF プログラムがない場合
(マップスロットに有効なプログラムファイルディスクリプターがない
場合、
または指定された検索インデックス/キーが範囲外である場合、
または入れ子の呼び出しが 32 の制限を肥えた場合)
現在の eBPF プログラムで実行が継続される。
.\"O This can be used as a fall-through for default cases.
これは、失敗した場合のデフォルトとして、使われる。
.IP
.\"O A program array map is useful, for example, in tracing or networking, to
.\"O handle individual system calls or protocols in their own subprograms and
.\"O use their identifiers as an individual map index.
プログラム配列マップは、例えば、トレーシング、または
ネットワーキングで役に立つ。
プログラム配列マップ自身のサブプログラムで各システムコールや
プロトコルを扱ったり、それらの識別子を各マップのインデックスとして
使うことが出来る。
.\"O This approach may result in performance benefits,
.\"O and also makes it possible to overcome the maximum
.\"O instruction limit of a single eBPF program.
この方法は性能上の利点になり、単一の eBPF プログラムの
命令数の制限の最大値を超えることもできる。
.\"O In dynamic environments,
.\"O a user-space daemon might atomically replace individual subprograms
.\"O at run-time with newer versions to alter overall program behavior,
.\"O for instance, if global policies change.
動的な環境では、ユーザ空間のデーモンは、実行時に各サブプログラムを
新バージョンに自動的に置き換え、たとえば、グローバルなポリシーを
変更することで、プログラムの挙動全体を変更することができる。
.\"
.\"O .SS eBPF programs
.SS eBPF プログラム
.\"O The
.\"O .B BPF_PROG_LOAD
.\"O command is used to load an eBPF program into the kernel.
.B BPF_PROG_LOAD
コマンドを使って、eBPF プログラムをカーネルにロードすることができる。
.\"O The return value for this command is a new file descriptor associated
.\"O with this eBPF program.
このコマンドの返り値は、この eBPF プログラムに関連づけられた
新しいファイルディスクリプターである。
.PP
.in +4n
.EX
char bpf_log_buf[LOG_BUF_SIZE];

int
bpf_prog_load(enum bpf_prog_type type,
              const struct bpf_insn *insns, int insn_cnt,
              const char *license)
{
    union bpf_attr attr = {
        .prog_type = type,
        .insns     = ptr_to_u64(insns),
        .insn_cnt  = insn_cnt,
        .license   = ptr_to_u64(license),
        .log_buf   = ptr_to_u64(bpf_log_buf),
        .log_size  = LOG_BUF_SIZE,
        .log_level = 1,
    };

    return bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
}
.EE
.in
.PP
.\"O .I prog_type
.\"O is one of the available program types:
.I prog_type
は以下の利用可能なプログラムタイプのうちのいずれかである:
.IP
.in +4n
.EX
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC,        /* Reserve 0 as invalid
                                    program type */
    BPF_PROG_TYPE_SOCKET_FILTER,
    BPF_PROG_TYPE_KPROBE,
    BPF_PROG_TYPE_SCHED_CLS,
    BPF_PROG_TYPE_SCHED_ACT,
    BPF_PROG_TYPE_TRACEPOINT,
    BPF_PROG_TYPE_XDP,
    BPF_PROG_TYPE_PERF_EVENT,
    BPF_PROG_TYPE_CGROUP_SKB,
    BPF_PROG_TYPE_CGROUP_SOCK,
    BPF_PROG_TYPE_LWT_IN,
    BPF_PROG_TYPE_LWT_OUT,
    BPF_PROG_TYPE_LWT_XMIT,
    BPF_PROG_TYPE_SOCK_OPS,
    BPF_PROG_TYPE_SK_SKB,
    BPF_PROG_TYPE_CGROUP_DEVICE,
    BPF_PROG_TYPE_SK_MSG,
    BPF_PROG_TYPE_RAW_TRACEPOINT,
    BPF_PROG_TYPE_CGROUP_SOCK_ADDR,
    BPF_PROG_TYPE_LWT_SEG6LOCAL,
    BPF_PROG_TYPE_LIRC_MODE2,
    BPF_PROG_TYPE_SK_REUSEPORT,
    BPF_PROG_TYPE_FLOW_DISSECTOR,
    /* See /usr/include/linux/bpf.h for the full list. */
};
.EE
.in
.PP
.\"O For further details of eBPF program types, see below.
eBPF プログラム型のより詳細については、下記を参照すること。
.PP
.\"O The remaining fields of
.\"O .I bpf_attr
.\"O are set as follows:
.I bpf_attr
の残りのフィールドは以下のように設定される:
.IP * 3
.\"O .I insns
.\"O is an array of
.\"O .I "struct bpf_insn"
.\"O instructions.
.I insns
は
.I "struct bpf_insn"
命令の配列である。
.IP *
.\"O .I insn_cnt
.\"O is the number of instructions in the program referred to by
.\"O .IR insns .
.I insn_cnt
は
.I insns
で参照されるプログラムの命令数である。
.IP *
.\"O .I license
.\"O is a license string, which must be GPL compatible to call helper functions
.\"O marked
.\"O .IR gpl_only .
.I license
はライセンス文字列であり、
.I gpl_only
とマークされているヘルパー関数を呼ぶために、GPL 互換でなければならない。
.\"O (The licensing rules are the same as for kernel modules,
.\"O so that also dual licenses, such as "Dual BSD/GPL", may be used.)
(ライセンシングのルールは、カーネルモジュールと同じであり、
"Dual BSD/GPL" のようなデュアルライセンスも使える。)
.IP *
.\"O .I log_buf
.\"O is a pointer to a caller-allocated buffer in which the in-kernel
.\"O verifier can store the verification log.
.I log_buf
は、呼び出し側によって確保されたバッファーであり、
カーネル内の検証器が検証ログを格納できる。
.\"O This log is a multi-line string that can be checked by
.\"O the program author in order to understand how the verifier came to
.\"O the conclusion that the eBPF program is unsafe.
ログは、複数行の文字列であり、
検証器がどのようにして eBPF プログラムが安全でないとの結論にしたかを、プログラムの作者が知るために
チェックできる。
.\"O The format of the output can change at any time as the verifier evolves.
出力の形式は、検証器の開発が進むにつれて、変更される可能性がある。
.IP *
.\"O .I log_size
.\"O size of the buffer pointed to by
.\"O .IR log_buf .
.I log_size
は
.I log_buf
で指されるバッファーのサイズである。
.\"O If the size of the buffer is not large enough to store all
.\"O verifier messages, \-1 is returned and
.\"O .I errno
.\"O is set to
.\"O .BR ENOSPC .
バッファーサイズが、検証器のすべてのメッセージを格納するのに
充分でない場合、\-1 が返され、
.I errno
が
.B ENOSPC
に設定される。
.IP *
.\"O .I log_level
.\"O verbosity level of the verifier.
.I log_level
は検証器の詳細レベルである。
.\"O A value of zero means that the verifier will not provide a log;
値を 0 にすると、検証器はログを出力しない。
.\"O in this case,
.\"O .I log_buf
.\"O must be a NULL pointer, and
.\"O .I log_size
.\"O must be zero.
この場合、
.I log_buf
は NULL ポインターでなければならず、
.I log_size
は 0 でなければならない。
.PP
.\"O Applying
.\"O .BR close (2)
.\"O to the file descriptor returned by
.\"O .B BPF_PROG_LOAD
.\"O will unload the eBPF program (but see NOTES).
.B BPF_PROG_LOAD
で返されるファイルディスクリプターを
.BR close (2)
を適用すると、eBPF プログラムをアンロードする
(「注意」を参照すること)。
.PP
.\"O Maps are accessible from eBPF programs and are used to exchange data between
.\"O eBPF programs and between eBPF programs and user-space programs.
マップは eBPF プログラムからアクセス可能であり、
eBPF プログラム間や、eBPF プログラムとユーザ空間プログラムの間で、
データを交換するのに使える。
.\"O For example,
.\"O eBPF programs can process various events (like kprobe, packets) and
.\"O store their data into a map,
.\"O and user-space programs can then fetch data from the map.
例えば、eBPF プログラムは (kprobe, パケットのような) さまざまなイベントを処理可能で、
そのデータをマップに格納できる。
そして、ユーザ空間プログラムはマップからそのデータを取得できる。
.\"O Conversely, user-space programs can use a map as a configuration mechanism,
.\"O populating the map with values checked by the eBPF program,
.\"O which then modifies its behavior on the fly according to those values.
逆に、ユーザ空間プログラムはマップを設定の仕組みとして使うことができる。
eBPF プログラムがチェックする値を含むマップを渡すことで、
この値に基づいて、即時にプログラムの挙動を変更することができる。
.\"
.\"
.\"O .SS eBPF program types
.SS eBPF プログラム型
.\"O The eBPF program type
.\"O .RI ( prog_type )
.\"O determines the subset of kernel helper functions that the program
.\"O may call.
eBPF プログラム型
.RI ( prog_type )
は、プログラムが呼ばれるカーネルヘルパー関数のサブセットを決定する。
.\"O The program type also determines the program input (context)\(emthe
.\"O format of
.\"O .I "struct bpf_context"
.\"O (which is the data blob passed into the eBPF program as the first argument).
プログラム型は、プログラムの入力 (コンテキスト)\(em
つまり
.I "struct bpf_context"
のフォーマットも決定する。
.RI ( "struct bpf_context"
は、データ blob で、eBPF プログラムの最初の引き数として渡される)。
.\"
.\" FIXME
.\" Somewhere in this page we need a general introduction to the
.\" bpf_context. For example, how does a BPF program access the
.\" context?
.PP
.\"O For example, a tracing program does not have the exact same
.\"O subset of helper functions as a socket filter program
.\"O (though they may have some helpers in common).
例えば、トレーシングプログラムは、ソケットフィルタープログラムとは、
厳密には同じヘルパー関数のサブセットを持たない
(しかし、いくつかのヘルパー関数は共通に持つ)。
.\"O Similarly,
.\"O the input (context) for a tracing program is a set of register values,
.\"O while for a socket filter it is a network packet.
同様に、トレーシングプログラムの入力 (コンテキスト) はレジスター値の集合であるが、
ソケットフィルターの入力 (コンテキスト) はネットワークパケットである。
.PP
.\"O The set of functions available to eBPF programs of a given type may increase
.\"O in the future.
指定された型の eBPF プログラムで利用可能な関数のセットは、
将来増えるかもしれない。
.PP
.\"O The following program types are supported:
以下のプログラム型がサポートされている:
.TP
.\"O .BR BPF_PROG_TYPE_SOCKET_FILTER " (since Linux 3.19)"
.BR BPF_PROG_TYPE_SOCKET_FILTER " (Linux 3.19 以降)"
.\"O Currently, the set of functions for
.\"O .B BPF_PROG_TYPE_SOCKET_FILTER
.\"O is:
現在、
.B BPF_PROG_TYPE_SOCKET_FILTER
で利用可能な関数のセットは以下の通り:
.IP
.in +4n
.EX
bpf_map_lookup_elem(map_fd, void *key)
                    /* look up key in a map_fd */
bpf_map_update_elem(map_fd, void *key, void *value)
                    /* update key/value */
bpf_map_delete_elem(map_fd, void *key)
                    /* delete key in a map_fd */
.EE
.in
.IP
.\"O The
.\"O .I bpf_context
.\"O argument is a pointer to a
.\"O .IR "struct __sk_buff" .
.I bpf_context
引き数は、
.I "struct __sk_buff"
へのポインターである。
.\" FIXME: We need some text here to explain how the program
.\" accesses __sk_buff.
.\" See 'struct __sk_buff' and commit 9bac3d6d548e5
.\"
.\" Alexei commented:
.\" Actually now in case of SOCKET_FILTER, SCHED_CLS, SCHED_ACT
.\" the program can now access skb fields.
.\"
.TP
.\"O .BR BPF_PROG_TYPE_KPROBE " (since Linux 4.1)"
.BR BPF_PROG_TYPE_KPROBE " (Linux 4.1 以降)"
.\" commit 2541517c32be2531e0da59dfd7efc1ce844644f5
.\"O [To be documented]
[ドキュメント化が必要]
.\" FIXME Document this program type
.\"	  Describe allowed helper functions for this program type
.\"	  Describe bpf_context for this program type
.\"
.\" FIXME We need text here to describe 'kern_version'
.TP
.\"O .BR BPF_PROG_TYPE_SCHED_CLS " (since Linux 4.1)"
.BR BPF_PROG_TYPE_SCHED_CLS " (Linux 4.1 以降)"
.\" commit 96be4325f443dbbfeb37d2a157675ac0736531a1
.\" commit e2e9b6541dd4b31848079da80fe2253daaafb549
.\"O [To be documented]
[ドキュメント化が必要]
.\" FIXME Document this program type
.\"	  Describe allowed helper functions for this program type
.\"	  Describe bpf_context for this program type
.TP
.\"O .BR BPF_PROG_TYPE_SCHED_ACT " (since Linux 4.1)"
.BR BPF_PROG_TYPE_SCHED_ACT " (Linux 4.1 以降)"
.\" commit 94caee8c312d96522bcdae88791aaa9ebcd5f22c
.\" commit a8cb5f556b567974d75ea29c15181c445c541b1f
.\"O [To be documented]
[ドキュメント化が必要]
.\" FIXME Document this program type
.\"	  Describe allowed helper functions for this program type
.\"	  Describe bpf_context for this program type
.\"O .SS Events
.SS イベント
.\"O Once a program is loaded, it can be attached to an event.
プログラムが 1 度ロードされると、イベントに紐づけられる。
.\"O Various kernel subsystems have different ways to do so.
いろいろなカーネルサブシステムが、さまざまな方法でこれを行う。
.PP
.\"O Since Linux 3.19,
.\"O .\" commit 89aa075832b0da4402acebd698d0411dcc82d03e
.\"O the following call will attach the program
.\"O .I prog_fd
.\"O to the socket
.\"O .IR sockfd ,
.\"O which was created by an earlier call to
.\"O .BR socket (2):
Linux 3.19 以降では、以下の呼び出しで、プログラム
.I prog_fd
をソケット
.I sockfd
に紐づける。
ここで、
.I sockfd
は
.BR socket (2)
の呼び出しで前もって作られたものである:
.PP
.in +4n
.EX
setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_BPF,
           &prog_fd, sizeof(prog_fd));
.EE
.in
.PP
.\"O Since Linux 4.1,
.\"O .\" commit 2541517c32be2531e0da59dfd7efc1ce844644f5
.\"O the following call may be used to attach
.\"O the eBPF program referred to by the file descriptor
.\"O .I prog_fd
.\"O to a perf event file descriptor,
.\"O .IR event_fd ,
.\"O that was created by a previous call to
.\"O .BR perf_event_open (2):
Linux 4.1 以降では、以下の呼び出しで、
ファイルディスクリプター
.I prog_fd
で参照される eBPF プログラムを、
perf イベントディスクリプター
.I event_fd
に紐づける。
ここで、
.I event_fd
は
.BR perf_event_open (2)
の呼び出しで前もって作られたものである:
.PP
.in +4n
.EX
ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, prog_fd);
.EE
.in
.\"
.\"
.\"O .SH EXAMPLES
.SH 例
.EX
.\"O /* bpf+sockets example:
.\"O  * 1. create array map of 256 elements
.\"O  * 2. load program that counts number of packets received
.\"O  *    r0 = skb->data[ETH_HLEN + offsetof(struct iphdr, protocol)]
.\"O  *    map[r0]++
.\"O  * 3. attach prog_fd to raw socket via setsockopt()
.\"O  * 4. print number of received TCP/UDP packets every second
.\"O  */
/* bpf とソケットの例:
 * 1. 要素数 256 の配列マップを作成する。
 * 2. 受信したパケット数をカウントするプログラムをロードする。
 *    r0 = skb->data[ETH_HLEN + offsetof(struct iphdr, protocol)]
 *    map[r0]++
 * 3. setsockopt() で prog_fd を raw ソケットに紐づける。
 * 4. 受信した TCP/UDP パケット数を毎秒表示する。
 */
int
main(int argc, char **argv)
{
    int sock, map_fd, prog_fd, key;
    long long value = 0, tcp_cnt, udp_cnt;

    map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key),
                            sizeof(value), 256);
    if (map_fd < 0) {
        printf("failed to create map '%s'\en", strerror(errno));
        /* likely not run as root */
        return 1;
    }

    struct bpf_insn prog[] = {
        BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),        /* r6 = r1 */
        BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol)),
                                /* r0 = ip->proto */
        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),
                                /* *(u32 *)(fp - 4) = r0 */
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /* r2 = fp */
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /* r2 = r2 - 4 */
        BPF_LD_MAP_FD(BPF_REG_1, map_fd),           /* r1 = map_fd */
        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),
                                /* r0 = map_lookup(r1, r2) */
        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),
                                /* if (r0 == 0) goto pc+2 */
        BPF_MOV64_IMM(BPF_REG_1, 1),                /* r1 = 1 */
        BPF_XADD(BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0),
                                /* lock *(u64 *) r0 += r1 */
.\"                                == atomic64_add
        BPF_MOV64_IMM(BPF_REG_0, 0),                /* r0 = 0 */
        BPF_EXIT_INSN(),                            /* return r0 */
    };

    prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog,
                            sizeof(prog) / sizeof(prog[0]), "GPL");

    sock = open_raw_sock("lo");

    assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd,
                      sizeof(prog_fd)) == 0);

    for (;;) {
        key = IPPROTO_TCP;
        assert(bpf_lookup_elem(map_fd, &key, &tcp_cnt) == 0);
        key = IPPROTO_UDP;
        assert(bpf_lookup_elem(map_fd, &key, &udp_cnt) == 0);
        printf("TCP %lld UDP %lld packets\en", tcp_cnt, udp_cnt);
        sleep(1);
    }

    return 0;
}
.EE
.PP
.\"O Some complete working code can be found in the
.\"O .I samples/bpf
.\"O directory in the kernel source tree.
動作している完全なコードは、カーネルソースツリーの
.I samples/bpf
にある。
.\"O .SH RETURN VALUE
.SH 返り値
.\"O For a successful call, the return value depends on the operation:
呼び出しに成功した場合、返り値は操作に依存する:
.TP
.B BPF_MAP_CREATE
.\"O The new file descriptor associated with the eBPF map.
eBPF マップに関連づけられた新しいファイルディスクリプター。
.TP
.B BPF_PROG_LOAD
.\"O The new file descriptor associated with the eBPF program.
eBPF プログラムに関連づけられた新しいファイルディスクリプター。
.TP
.\"O All other commands
他のコマンド
.\"O Zero.
0。
.PP
.\"O On error, \-1 is returned, and
.\"O .I errno
.\"O is set appropriately.
エラーの場合、\-1 が返され、
.I errno
が適切に設定される。
.\"O .SH ERRORS
.SH エラー
.TP
.B E2BIG
.\"O The eBPF program is too large or a map reached the
.\"O .I max_entries
.\"O limit (maximum number of elements).
eBPF プログラムが大きすぎる、またはマップが
.I max_entries
の制限 (要素数の最大値) に達した。
.TP
.B EACCES
.\"O For
.\"O .BR BPF_PROG_LOAD ,
.\"O even though all program instructions are valid, the program has been
.\"O rejected because it was deemed unsafe.
.B BPF_PROG_LOAD
の場合に、すべてのプログラム命令が有効であるが、
プログラムが安全でないと思われて、拒否された。
.\"O This may be because it may have
.\"O accessed a disallowed memory region or an uninitialized stack/register or
.\"O because the function constraints don't match the actual types or because
.\"O there was a misaligned memory access.
これは、許可されていないメモリ領域または初期化されていない
スタック/レジスタにアクセスする可能性がある場合、
関数の制限が実際のタイプにマッチしない場合、
配置を間違えたメモリアクセスがある場合などである。
.\"O In this case, it is recommended to call
.\"O .BR bpf ()
.\"O again with
.\"O .I log_level = 1
.\"O and examine
.\"O .I log_buf
.\"O for the specific reason provided by the verifier.
この場合、
.BR bpf ()
を
.I log_level = 1
としてもう一度呼んで、検証器が提供する特定の理由を
.I log_buf
で調べることをお勧めする。
.TP
.B EBADF
.\"O .I fd
.\"O is not an open file descriptor.
.I fd
がオープンされたファイルディスクリプターでない。
.TP
.B EFAULT
.\"O One of the pointers
.\"O .RI ( key
.\"O or
.\"O .I value
.\"O or
.\"O .I log_buf
.\"O or
.\"O .IR insns )
.\"O is outside the accessible address space.
ポインター
.RI ( key ,
.IR value ,
.IR log_buf ,
.IR insns )
のいずれかが、アクセス可能はアドレス空間の外にある。
.TP
.B EINVAL
.\"O The value specified in
.\"O .I cmd
.\"O is not recognized by this kernel.
.I cmd
に指定された値が、カーネルに認識されない。
.TP
.B EINVAL
.\"O For
.\"O .BR BPF_MAP_CREATE ,
.\"O either
.\"O .I map_type
.\"O or attributes are invalid.
.B BPF_MAP_CREATE
の場合に、
.I map_type
または属性が無効である。
.TP
.B EINVAL
.\"O For
.\"O .B BPF_MAP_*_ELEM
.\"O commands,
.\"O some of the fields of
.\"O .I "union bpf_attr"
.\"O that are not used by this command
.\"O are not set to zero.
.B BPF_MAP_*_ELEM
コマンドの場合に、このコマンドで使われない
.I "union bpf_attr"
のどれかのフィールドが 0 に設定されていない。
.TP
.B EINVAL
.\"O For
.\"O .BR BPF_PROG_LOAD ,
.\"O indicates an attempt to load an invalid program.
.B BPF_PROG_LOAD
の場合に、無効なプログラムをロードしようとしたことを表す。
.\"O eBPF programs can be deemed
.\"O invalid due to unrecognized instructions, the use of reserved fields, jumps
.\"O out of range, infinite loops or calls of unknown functions.
eBPF プログラムは、認識されない命令、予約されたフィールドの利用、
範囲外へのジャンプ、無限ループ、不明な関数呼び出しの場合に、
無効であると認識される。
.TP
.B ENOENT
.\"O For
.\"O .B BPF_MAP_LOOKUP_ELEM
.\"O or
.\"O .BR BPF_MAP_DELETE_ELEM ,
.\"O indicates that the element with the given
.\"O .I key
.\"O was not found.
.B BPF_MAP_LOOKUP_ELEM
または
.B BPF_MAP_DELETE_ELEM
の場合、指定された
.I key
の要素が見つからないことを示す。
.TP
.B ENOMEM
.\"O Cannot allocate sufficient memory.
十分なメモリが確保できない。
.TP
.B EPERM
.\"O The call was made without sufficient privilege
.\"O (without the
.\"O .B CAP_SYS_ADMIN
.\"O capability).
十分な権限
.RB ( CAP_SYS_ADMIN
ケーパビリティ) なしで呼び出しが行われた。
.\"O .SH VERSIONS
.SH バージョン
.\"O The
.\"O .BR bpf ()
.\"O system call first appeared in Linux 3.18.
.BR bpf ()
は Linux 3.18 で最初に登場した。
.\"O .SH CONFORMING TO
.SH 準拠
.\"O The
.\"O .BR bpf ()
.\"O system call is Linux-specific.
.BR bpf ()
システムコールは Linux 固有である。
.\"O .SH NOTES
.SH 注意
.\"O Prior to Linux 4.4, all
.\"O .BR bpf ()
.\"O commands require the caller to have the
.\"O .B CAP_SYS_ADMIN
.\"O capability.
Linux 4.4 より前では、すべての
.BR bpf ()
コマンドで、呼び出し元が
.B CAP_SYS_ADMIN
ケーパビリティを持つ必要があった。
.\"O From Linux 4.4 onwards,
.\"O .\" commit 1be7f75d1668d6296b80bf35dcf6762393530afc
.\"O an unprivileged user may create limited programs of type
.\"O .BR BPF_PROG_TYPE_SOCKET_FILTER
.\"O and associated maps.
Linux 4.4 以降では、特権のないユーザでもタイプ
.BR BPF_PROG_TYPE_SOCKET_FILTER
と関連するマップの限定されたプログラムを作れるようになった。
.\"O However they may not store kernel pointers within
.\"O the maps and are presently limited to the following helper functions:
しかし、マップにカーネルのポインターを格納できず、現在のところ下記の
ヘルパー関数に限定されている:
.\" [Linux 5.6] mtk: The list of available functions is, I think, governed
.\" by the check in net/core/filter.c::bpf_base_func_proto().
.IP * 3
get_random
.PD 0
.IP *
get_smp_processor_id
.IP *
tail_call
.IP *
ktime_get_ns
.PD 1
.PP
.\"O Unprivileged access may be blocked by setting the sysctl
.\"O .IR /proc/sys/kernel/unprivileged_bpf_disabled .
特権のないアクセスは、sysctl
.I /proc/sys/kernel/unprivileged_bpf_disabled
を設定することで、ブロックできる。
.PP
.\"O eBPF objects (maps and programs) can be shared between processes.
eBPF オブジェクト (マップとプログラム) は、プロセス間で共有できる。
.\"O For example, after
.\"O .BR fork (2),
.\"O the child inherits file descriptors referring to the same eBPF objects.
例えば、
.BR fork (2)
の後、子プロセスは、同じ eBPF オブジェクトを参照するファイルディスクリプターを継承する。
.\"O In addition, file descriptors referring to eBPF objects can be
.\"O transferred over UNIX domain sockets.
加えて、eBPF オブジェクトを参照するファイルディスクリプターは、
UNIX ドメインソケットを使って転送できる。
.\"O File descriptors referring to eBPF objects can be duplicated
.\"O in the usual way, using
.\"O .BR dup (2)
.\"O and similar calls.
eBPF オブジェクトを参照するファイルディスクリプターは、
.BR dup (2)
や同様の呼び出しで、通常の方法で複製できる。
.\"O An eBPF object is deallocated only after all file descriptors
.\"O referring to the object have been closed.
eBPF オブジェクトは、オブジェクトを参照するすべてのファイルディスクリプターが
閉じられた場合に、解放される。
.PP
.\"O eBPF programs can be written in a restricted C that is compiled (using the
.\"O .B clang
.\"O compiler) into eBPF bytecode.
eBPF プログラムは、制限付きの C で書くことができて、
.RB ( clang
コンパイラーを使って) eBPF バイトコードにコンパイルされる。
.\"O Various features are omitted from this restricted C, such as loops,
.\"O global variables, variadic functions, floating-point numbers,
.\"O and passing structures as function arguments.
制限付きの C では、ループ、グローバル変数、可変長期引き数の関数、
浮動小数点小数、構造体の関数引き数への受け渡しなど、
さまざまな機能が省略されている。
.\"O Some examples can be found in the
.\"O .I samples/bpf/*_kern.c
.\"O files in the kernel source tree.
カーネルソースコードツリーの
.I samples/bpf/*_kern.c
ファイルに、いくつかの例が書かれている。
.\" There are also examples for the tc classifier, in the iproute2
.\" project, in examples/bpf
.PP
.\"O The kernel contains a just-in-time (JIT) compiler that translates
.\"O eBPF bytecode into native machine code for better performance.
カーネルは just-in-time (JIT) を含んでおり、
eBPF バイトコードをネイティブのマシンコードに変換し、
性能を良くすることができる。
.\"O In kernels before Linux 4.15,
.\"O the JIT compiler is disabled by default,
.\"O but its operation can be controlled by writing one of the
.\"O following integer strings to the file
.\"O .IR /proc/sys/net/core/bpf_jit_enable :
Linux 4.15 より前のカーネルでは、
デフォルトでは JIT コンパイラーは無効化されているが、
下記の整数文字列のいずれかを
.I /proc/sys/net/core/bpf_jit_enable
に書き込むことにより、操作をコントロールできる。
.IP 0 3
.\"O Disable JIT compilation (default).
JIT コンパイルを無効化する (デフォルト)。
.IP 1
.\"O Normal compilation.
通常のコンパイル。
.IP 2
.\"O Debugging mode.
デバッグモード。
.\"O The generated opcodes are dumped in hexadecimal into the kernel log.
生成されたオペコード (opcode) はカーネルログに 16 進数でダンプされる。
.\"O These opcodes can then be disassembled using the program
.\"O .I tools/net/bpf_jit_disasm.c
.\"O provided in the kernel source tree.
これらのオペコードは、カーネルソースツリーの
.I tools/net/bpf_jit_disasm.c
で提供されるプログラムで逆アセンブルできる。
.PP
.\"O Since Linux 4.15,
.\"O .\" commit 290af86629b25ffd1ed6232c4e9107da031705cb
.\"O the kernel may configured with the
.\"O .B CONFIG_BPF_JIT_ALWAYS_ON
.\"O option.
Linux 4.15 以降では、カーネルが
.B CONFIG_BPF_JIT_ALWAYS_ON
オプション付きで設定されているかもしれない。
.\"O In this case, the JIT compiler is always enabled, and the
.\"O .I bpf_jit_enable
.\"O is initialized to 1 and is immutable.
この場合、JIT コンパイラーは常に有効になっており、
.I bpf_jit_enable
は 1 で初期化されており、変更できない。
.\"O (This kernel configuration option was provided as a mitigation for
.\"O one of the Spectre attacks against the BPF interpreter.)
(このカーネル設定オプションは、BPF インタプリターへのスペクター (Spectre) アタックを
緩和するために提供されている。)
.PP
.\"O The JIT compiler for eBPF is currently
.\"O .\" Last reviewed in Linux 4.18-rc by grepping for BPF_ALU64 in arch/
.\"O .\" and by checking the documentation for bpf_jit_enable in
.\"O .\" Documentation/sysctl/net.txt
.\"O available for the following architectures:
JIT コンパイラーは、現在のところ下記のアーキテクチャーで提供されている:
.IP * 3
.\"O x86-64 (since Linux 3.18; cBPF since Linux 3.0);
x86-64 (Linux 3.18 以降; cBPF は Linux 3.0 以降);
.\" commit 0a14842f5a3c0e88a1e59fac5c3025db39721f74
.PD 0
.IP *
.\"O ARM32 (since Linux 3.18; cBPF since Linux 3.4);
ARM32 (Linux 3.18 以降; cBPF は Linux 3.4 以降);
.\" commit ddecdfcea0ae891f782ae853771c867ab51024c2
.IP *
.\"O SPARC 32 (since Linux 3.18; cBPF since Linux 3.5);
SPARC 32 (Linux 3.18 以降; cBPF は Linux 3.5 以降);
.\" commit 2809a2087cc44b55e4377d7b9be3f7f5d2569091
.IP *
.\"O ARM-64 (since Linux 3.18);
ARM-64 (Linux 3.18 以降);
.\" commit e54bcde3d69d40023ae77727213d14f920eb264a
.IP *
.\"O s390 (since Linux 4.1; cBPF since Linux 3.7);
s390 (Linux 4.1 以降; cBPF は Linux 3.7 以降);
.\" commit c10302efe569bfd646b4c22df29577a4595b4580
.IP *
.\"O PowerPC 64 (since Linux 4.8; cBPF since Linux 3.1);
PowerPC 64 (Linux 4.8 以降; cBPF は Linux 3.1 以降);
.\" commit 0ca87f05ba8bdc6791c14878464efc901ad71e99
.\" commit 156d0e290e969caba25f1851c52417c14d141b24
.IP *
.\"O SPARC 64 (since Linux 4.12);
SPARC 64 (Linux 4.12 以降);
.\" commit 7a12b5031c6b947cc13918237ae652b536243b76
.IP *
.\"O x86-32 (since Linux 4.18);
x86-32 (Linux 4.18 以降);
.\" commit 03f5781be2c7b7e728d724ac70ba10799cc710d7
.IP *
.\"O MIPS 64 (since Linux 4.18; cBPF since Linux 3.16);
MIPS 64 (Linux 4.18 以降; cBPF は Linux 3.16 以降);
.\" commit c6610de353da5ca6eee5b8960e838a87a90ead0c
.\" commit f381bf6d82f032b7410185b35d000ea370ac706b
.IP *
.\"O riscv (since Linux 5.1).
riscv (Linux 5.1 以降).
.\" commit 2353ecc6f91fd15b893fa01bf85a1c7a823ee4f2
.PD
.\"O .SH SEE ALSO
.SH 関連項目
.BR seccomp (2),
.BR bpf-helpers (7),
.BR socket (7),
.BR tc (8),
.BR tc-bpf (8)
.PP
.\"O Both classic and extended BPF are explained in the kernel source file
.\"O .IR Documentation/networking/filter.txt .
classic BPF と extended BPF の両方が、カーネルソースコード
.I Documentation/networking/filter.txt
で説明されている。

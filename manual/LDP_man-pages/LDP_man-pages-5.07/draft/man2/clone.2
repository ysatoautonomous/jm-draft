.\" Copyright (c) 1992 Drew Eckhardt <drew@cs.colorado.edu>, March 28, 1992
.\" and Copyright (c) Michael Kerrisk, 2001, 2002, 2005, 2013, 2019
.\"
.\" %%%LICENSE_START(GPL_NOVERSION_ONELINE)
.\" May be distributed under the GNU General Public License.
.\" %%%LICENSE_END
.\"
.\" Modified by Michael Haardt <michael@moria.de>
.\" Modified 24 Jul 1993 by Rik Faith <faith@cs.unc.edu>
.\" Modified 21 Aug 1994 by Michael Chastain <mec@shell.portal.com>:
.\"   New man page (copied from 'fork.2').
.\" Modified 10 June 1995 by Andries Brouwer <aeb@cwi.nl>
.\" Modified 25 April 1998 by Xavier Leroy <Xavier.Leroy@inria.fr>
.\" Modified 26 Jun 2001 by Michael Kerrisk
.\"     Mostly upgraded to 2.4.x
.\"     Added prototype for sys_clone() plus description
.\"	Added CLONE_THREAD with a brief description of thread groups
.\"	Added CLONE_PARENT and revised entire page remove ambiguity
.\"		between "calling process" and "parent process"
.\"	Added CLONE_PTRACE and CLONE_VFORK
.\"	Added EPERM and EINVAL error codes
.\"	Renamed "__clone" to "clone" (which is the prototype in <sched.h>)
.\"	various other minor tidy ups and clarifications.
.\" Modified 26 Jun 2001 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Updated notes for 2.4.7+ behavior of CLONE_THREAD
.\" Modified 15 Oct 2002 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Added description for CLONE_NEWNS, which was added in 2.4.19
.\" Slightly rephrased, aeb.
.\" Modified 1 Feb 2003 - added CLONE_SIGHAND restriction, aeb.
.\" Modified 1 Jan 2004 - various updates, aeb
.\" Modified 2004-09-10 - added CLONE_PARENT_SETTID etc. - aeb.
.\" 2005-04-12, mtk, noted the PID caching behavior of NPTL's getpid()
.\"	wrapper under BUGS.
.\" 2005-05-10, mtk, added CLONE_SYSVSEM, CLONE_UNTRACED, CLONE_STOPPED.
.\" 2005-05-17, mtk, Substantially enhanced discussion of CLONE_THREAD.
.\" 2008-11-18, mtk, order CLONE_* flags alphabetically
.\" 2008-11-18, mtk, document CLONE_NEWPID
.\" 2008-11-19, mtk, document CLONE_NEWUTS
.\" 2008-11-19, mtk, document CLONE_NEWIPC
.\" 2008-11-19, Jens Axboe, mtk, document CLONE_IO
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.\"
.\" Japanese Version Copyright (c) 2001 HANATAKA Shinya
.\"     and Copyright(c) 2002, 2005-2008 Akihiro MOTOKI
.\" Translated 2001-08-17, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Modified 2002-09-24, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Modified 2005-02-02, Akihiro MOTOKI
.\" Updated 2005-04-17, Akihiro MOTOKI
.\" Updated 2005-09-10, Akihiro MOTOKI
.\" Updated 2006-03-05, Akihiro MOTOKI, LDP v2.25
.\" Updated 2007-01-05, Akihiro MOTOKI, LDP v2.43
.\" Updated 2007-05-01, Akihiro MOTOKI, LDP v2.46
.\" Updated 2007-06-13, Akihiro MOTOKI, LDP v2.55
.\" Updated 2008-08-04, Akihiro MOTOKI, LDP v3.05
.\" Updated 2008-11-09, Akihiro MOTOKI, LDP v3.10
.\" Updated 2009-03-02, Akihiro MOTOKI, LDP v3.19
.\" Updated 2010-04-11, Akihiro MOTOKI, LDP v3.24
.\" Updated 2012-05-08, Akihiro MOTOKI <amotoki@gmail.com>
.\" Updated 2013-05-06, Akihiro MOTOKI <amotoki@gmail.com>
.\"
.TH CLONE 2 2020-06-09 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O clone, __clone2, clone3 \- create a child process
clone, __clone2, clone3 \- 子プロセスを作成する
.\"O .SH SYNOPSIS
.SH 書式
.nf
.\"O /* Prototype for the glibc wrapper function */
/* glibc ラッパー関数のプロトタイプ */
.PP
.B #define _GNU_SOURCE
.B #include <sched.h>
.PP
.BI "int clone(int (*" "fn" ")(void *), void *" stack \
", int " flags ", void *" "arg" ", ... "
.BI "          /* pid_t *" parent_tid ", void *" tls \
", pid_t *" child_tid " */ );"
.PP
.\"O /* For the prototype of the raw clone() system call, see NOTES */
/* 素の clone() システムコールのプロトタイプ。「注意」を参照 */
.PP
.BI "long clone3(struct clone_args *" cl_args ", size_t " size );
.fi
.PP
.\"O .IR Note :
.\"O There is not yet a glibc wrapper for
.\"O .BR clone3 ();
.\"O see NOTES.
.IR 注意 :
.BR clone3 ()
の glibc ラッパーは、まだ存在しない。
「注意」のセクションを参照すること。
.\"O .SH DESCRIPTION
.SH 説明
.\"O These system calls
.\"O create a new ("child") process, in a manner similar to
.\"O .BR fork (2).
これらのシステムコールは、
\fBfork\fP(2) と似た方法で新しい (「子」) プロセスを作成する。
.PP
.\"O By contrast with
.\"O .BR fork (2),
.\"O these system calls provide more precise control over what pieces of execution
.\"O context are shared between the calling process and the child process.
\fBfork\fP(2) とは異なり、これらのシステムコールは、
呼び出し元プロセスと子プロセスの間で、
実行コンテキストのうち何を共有するかを、より細かく制御できる。
.\"O For example, using these system calls, the caller can control whether
.\"O or not the two processes share the virtual address space,
.\"O the table of file descriptors, and the table of signal handlers.
例えば、これらのシステムコールを使うと、呼び出し元プロセスは、
2 つのプロセス (呼び出し元プロセスと子プロセス) の間で、
仮想アドレス空間、ファイルディスクリプターのテーブル、
シグナルハンドラーのテーブルを共有するか否かを制御できる。
.\"O These system calls also allow the new child process to be placed
.\"O in separate
.\"O .BR namespaces (7).
これらのシステムコールにより、新しい子プロセスを、別の
.BR namespaces (7)
に置くこともできる。
.PP
.\"O Note that in this manual
.\"O page, "calling process" normally corresponds to "parent process".
このマニュアルにおける「呼び出し元のプロセス」は、通常は 「親プロセス」と一致する。
.\"O But see the descriptions of
.\"O .B CLONE_PARENT
.\"O and
.\"O .B CLONE_THREAD
.\"O below.
ただし、後述の
.B CLONE_PARENT
と
.B CLONE_THREAD
の項も参照のこと。
.PP
.\"O This page describes the following interfaces:
このページでは、以下のインタフェースについて説明している。
.IP * 3
.\"O The glibc
.\"O .BR clone ()
.\"O wrapper function and the underlying system call on which it is based.
glibc の \fBclone\fP() ラッパー関数と、その裏で呼ばれるシステムコール。
.\"O The main text describes the wrapper function;
.\"O the differences for the raw system call
.\"O are described toward the end of this page.
メインの説明はラッパー関数に関するものである。
素のシステムコールにおける差分はこのページの最後の方で説明する。
.IP *
.\"O The newer
.\"O .BR clone3 ()
.\"O system call.
より新しい
.BR clone3 ()
システムコール。
.PP
.\"O In the remainder of this page, the terminology "the clone call" is used
.\"O when noting details that apply to all of these interfaces,
このページの残りの部分では、これらのインタフェースを適用する際に、
特に詳細がなければ、「clone 呼び出し」という用語を使う。
.\"
.\"O .SS The clone() wrapper function
.SS clone() ラッパー関数
.PP
.\"O When the child process is created with the
.\"O .BR clone ()
.\"O wrapper function,
.\"O it commences execution by calling the function pointed to by the argument
.IR fn .
\fBclone\fP() ラッパー関数で子プロセスが作成されると、
プロセスは引き数 \fIfn\fP で指された関数を呼び出して、
実行を開始する。
.\"O (This differs from
.\"O .BR fork (2),
.\"O where execution continues in the child from the point
.\"O of the
.\"O .BR fork (2)
.\"O call.)
(この点が \fBfork\fP(2) とは異なる。
\fBfork\fP(2) の場合、子プロセスは \fBfork\fP(2) が呼び出された場所から実行を続ける。)
.\"O The
.\"O .I arg
.\"O argument is passed as the argument of the function
.\"O .IR fn .
\fIarg\fP 引き数はそのまま \fIfn\fP 関数へと渡される。
.PP
.\"O When the
.\"O .IR fn ( arg )
.\"O function returns, the child process terminates.
\fIfn\fP(\fIarg\fP)  関数が終了すると、子プロセスは終了する。
.\"O The integer returned by
.\"O .I fn
.\"O is the exit status for the child process.
\fIfn\fP によって返された整数が子プロセスの返り値となる。
.\"O The child process may also terminate explicitly by calling
.\"O .BR exit (2)
.\"O or after receiving a fatal signal.
子プロセスは、\fBexit\fP(2) を呼んで明示的に終了することもあるし、
致命的なシグナルを受信した場合に終了することもある。
.PP
.\"O The
.\"O .I stack
.\"O argument specifies the location of the stack used by the child process.
\fIstack\fP 引き数は、子プロセスによって使用されるスタックの位置を指定する。
.\"O Since the child and calling process may share memory,
.\"O it is not possible for the child process to execute in the
.\"O same stack as the calling process.
子プロセスと呼び出し元のプロセスはメモリーを共有することがあるため、
子プロセスは呼び出し元のプロセスと同じスタックで実行することができない。
.\"O The calling process must therefore
.\"O set up memory space for the child stack and pass a pointer to this
.\"O space to
.\"O .BR clone ().
このため、呼び出し元のプロセスは子プロセスのスタックのためのメモリー
空間を用意して、この空間へのポインターを \fBclone\fP() へ渡さなければならない。
.\"O Stacks grow downward on all processors that run Linux
.\"O (except the HP PA processors), so
.\"O .I stack
.\"O usually points to the topmost address of the memory space set up for
.\"O the child stack.
(HP PA プロセッサ以外の) Linux が動作する全てのプロセッサでは、
スタックは下方 (アドレスが小さい方向) へと伸びる。
このため、普通は \fIstack\fP は子プロセスのスタックのために用意した
メモリー空間の一番大きいアドレスを指すようにする。
.\"O Note that
.\"O .BR clone ()
.\"O does not provide a means whereby the caller can inform the kernel of the
.\"O size of the stack area.
.BR clone ()
は、呼び出し元プロセスがカーネルにスタック領域のサイズを知らせる方法を
提供していない点に注意すること。
.PP
.\"O The remaining arguments to
.\"O .BR clone ()
.\"O are discussed below.
.BR clone ()
の残りの引き数については、以下で説明する。
.\"
.SS clone3()
.PP
.\"O The
.\"O .BR clone3 ()
.\"O system call provides a superset of the functionality of the older
.\"O .BR clone ()
.\"O interface.
.BR clone3 ()
システムコールは、昔の
.BR clone ()
インタフェースの機能の上位セットを提供する。
.\"O It also provides a number of API improvements, including:
.\"O space for additional flags bits;
.\"O cleaner separation in the use of various arguments;
.\"O and the ability to specify the size of the child's stack area.
また、次のような、いくつかの API の改良も加えられている:
フラグビットのためのスペースの追加。
いろいろな引き数の使い方を綺麗に分離。
子プロセスのスタックエリアのサイズの指定。
.PP
.\"O As with
.\"O .BR fork (2),
.\"O .BR clone3 ()
.\"O returns in both the parent and the child.
.BR fork (2)
と同じく
.BR clone3 ()
は、親プロセスと子プロセスを返す。
.\"O It returns 0 in the child process and returns the PID of the child
.\"O in the parent.
.BR clone3 ()
は、子プロセスの 0 を返し、親プロセスに子プロセスの PID を返す。
.PP
.\"O The
.\"O .I cl_args
.\"O argument of
.\"O .BR clone3 ()
.\"O is a structure of the following form:
.BR clone3 ()
の
.I cl_args
引き数は、以下のような構造体である。
.PP
.in +4n
.EX
struct clone_args {
.\"O     u64 flags;        /* Flags bit mask */
    u64 flags;        /* フラグのビットマスク */
.\"O     u64 pidfd;        /* Where to store PID file descriptor
.\"O                          (\fIpid_t *\fP) */
    u64 pidfd;        /* PID ファイルディスクリプターを
                         格納する場所 (\fIpid_t *\fP) */
.\"O     u64 child_tid;    /* Where to store child TID,
.\"O                          in child's memory (\fIpid_t *\fP) */
    u64 child_tid;    /* 子のメモリ内で、子の TID を
                         格納する場所 (\fIpid_t *\fP) */
.\"O     u64 parent_tid;   /* Where to store child TID,
.\"O                          in parent's memory (\fIint *\fP) */
    u64 parent_tid;   /* 親のメモリ内で、子の TID を
                         格納する場所 (\fIint *\fP) */
.\"O     u64 exit_signal;  /* Signal to deliver to parent on
.\"O                          child termination */
    u64 exit_signal;  /* 子が終了した時に親に送られるシグナル */
.\"O     u64 stack;        /* Pointer to lowest byte of stack */
    u64 stack;        /* スタックの最下位バイトへのポインター */
.\"O     u64 stack_size;   /* Size of stack */
    u64 stack_size;   /* スタックのサイズ */
.\"O     u64 tls;          /* Location of new TLS */
    u64 tls;          /* 新しい TLS の場所 */
.\"O     u64 set_tid;      /* Pointer to a \fIpid_t\fP array
.\"O                          (since Linux 5.5) */
    u64 set_tid;      /* \fIpid_t\fP 配列へのポインター
                         (Linux 5.5 以降) */
.\"O     u64 set_tid_size; /* Number of elements in \fIset_tid\fP
.\"O                          (since Linux 5.5) */
    u64 set_tid_size; /* \fIset_tid\fP の要素数
                         (Linux 5.5 以降) */
.\"O     u64 cgroup;       /* File descriptor for target cgroup
.\"O                          of child (since Linux 5.7) */
    u64 cgroup;       /* 子の対象 cgroup のファイルディスクリプター
                         (Linux 5.7 以降) */
};
.EE
.in
.PP
.\"O The
.\"O .I size
.\"O argument that is supplied to
.\"O .BR clone3 ()
.\"O should be initialized to the size of this structure.
.I size
引き数を
.BR clone3 ()
に指定することで、この構造体のサイズを初期化する。
.\"O (The existence of the
.\"O .I size
.\"O argument permits future extensions to the
.\"O .IR clone_args
.\"O structure.)
.RI ( size
引き数が存在することで、将来の
.IR clone_args
構造体の拡張ができる。)
.PP
.\"O The stack for the child process is specified via
.\"O .IR cl_args.stack ,
.\"O which points to the lowest byte of the stack area,
.\"O and
.\"O .IR cl_args.stack_size ,
.\"O which specifies the size of the stack in bytes.
子プロセスのスタックは
.I cl_args.stack
で指定され、スタック領域の最下位バイトを指す。
また、
.I cl_args.stack_size
は、スタックサイズのバイト数を指定する。
.\"O In the case where the
.\"O .BR CLONE_VM
.\"O flag (see below) is specified, a stack must be explicitly allocated
.\"O and specified.
.BR CLONE_VM
フラグ (下記を参照) が指定された場合、スタックは明示的に確保されて指定されなければならない。
.\"O Otherwise, these two fields can be specified as NULL and 0,
.\"O which causes the child to use the same stack area as the parent
.\"O (in the child's own virtual address space).
そうでない場合は、この 2 つのフィールドに NULL と 0 を指定して、
(子プロセス自身の仮想アドレス空間で)
子プロセスに親と同じスタック領域を使わせるようにする。
.PP
.\"O The remaining fields in the
.\"O .I cl_args
.\"O argument are discussed below.
.I cl_args
引き数の残りのフィールドは、以下で説明する。
.\"
.\"O .SS Equivalence between clone() and clone3() arguments
.SS clone() と clone3() の引き数の相違点
.PP
.\"O Unlike the older
.\"O .BR clone ()
.\"O interface, where arguments are passed individually, in the newer
.\"O .BR clone3 ()
.\"O interface the arguments are packaged into the
.\"O .I clone_args
.\"O structure shown above.
以前の
.BR clone ()
インタフェースでは、引き数が別々に渡されていたが、
新しい
.BR clone3 ()
インタフェースでは、引き数が上記の
.I clone_args
構造体にパッケージングされている。
.\"O This structure allows for a superset of the information passed via the
.\"O .BR clone ()
.\"O arguments.
この構造体は、
.BR clone ()
引き数で渡される情報の上位セットになっている。
.PP
.\"O The following table shows the equivalence between the arguments of
.\"O .BR clone ()
.\"O and the fields in the
.\"O .I clone_args
.\"O argument supplied to
.\"O .BR clone3 ():
下記の表は、
.BR clone ()
の引き数と、
.BR clone3 ()
に与えられる
.I clone_args
引き数のフィールドの相違点を表している:
.RS
.TS
lb lb lb
l l l
li li l.
.\"O clone()	clone3()	Notes
clone()	clone3()	注記
.\"O 	\fIcl_args\fP field
	\fIcl_args\fP フィールド
.\"O flags & ~0xff	flags	For most flags; details below
flags & ~0xff	flags	多くのフラグは下記を参照
.\"O parent_tid	pidfd	See CLONE_PIDFD
parent_tid	pidfd	CLONE_PIDFD を参照
.\"O child_tid	child_tid	See CLONE_CHILD_SETTID
child_tid	child_tid	CLONE_CHILD_SETTID を参照
.\"O parent_tid	parent_tid	See CLONE_PARENT_SETTID
parent_tid	parent_tid	CLONE_PARENT_SETTID を参照
flags & 0xff	exit_signal
stack	stack
\fP---\fP	stack_size
.\"O tls	tls	See CLONE_SETTLS
tls	tls	CLONE_SETTLS を参照
.\"O \fP---\fP	set_tid	See below for details
\fP---\fP	set_tid	詳細は下記を参照
\fP---\fP	set_tid_size
.\"O \fP---\fP	cgroup	See CLONE_INTO_CGROUP
\fP---\fP	cgroup	CLONE_INTO_CGROUP を参照
.TE
.RE
.\"
.\"O .SS The child termination signal
.SS 子の終了シグナル (termination signal)
.PP
.\"O When the child process terminates, a signal may be sent to the parent.
子プロセスが終了した場合、親にシグナルが送られる。
.\"O The termination signal is specified in the low byte of
.\"O .I flags
.\"O .RB ( clone ())
.\"O or in
.\"O .I cl_args.exit_signal
.\"O .RB ( clone3 ()).
終了シグナルは、
.RB ( clone ()
の場合)
.I flags
の下位バイト、
.RB ( clone3 ()
の場合)
.I cl_args.exit_signal
で指定される。
.\"O If this signal is specified as anything other than
.\"O .BR SIGCHLD ,
.\"O then the parent process must specify the
.\"O .B __WALL
.\"O or
.\"O .B __WCLONE
.\"O options when waiting for the child with
.\"O .BR wait (2).
このシグナルとして \fBSIGCHLD\fP 以外が指定された場合、
親プロセスは、\fBwait\fP(2) で子プロセスを待つ際に、
オプションとして \fB__WALL\fP または \fB__WCLONE\fP を指定しなければならない。
.\"O If no signal (i.e., zero) is specified, then the parent process is not signaled
.\"O when the child terminates.
どのシグナルも指定されなかった場合 (つまり 0 の場合)、
子プロセスが終了した時に親プロセスにシグナルは送られない。
.\"
.\"O .SS The set_tid array
.SS set_tid 配列
.PP
.\"O By default, the kernel chooses the next sequential PID for the new
.\"O process in each of the PID namespaces where it is present.
デフォルトでは、カーネルは、プロセスが存在する PID 名前空間から、
新しいプロセスに対して、連続する次の PID を選択する。
.\"O When creating a process with
.\"O .BR clone3 (),
.\"O the
.\"O .I set_tid
.\"O array (available since Linux 5.5)
.\"O can be used to select specific PIDs for the process in some
.\"O or all of the PID namespaces where it is present.
.BR clone3 ()
でプロセスを作成する場合、(Linux 5.5 以降で利用可能な)
.I set_tid
配列を使って、プロセスが存在する同じ PID 名前空間、またはすべての PID 名前空間の
プロセスに対して、特定の PID を選択する。
.\"O If the PID of the newly created process should be set only for the current
.\"O PID namespace or in the newly created PID namespace (if
.\"O .I flags
.\"O contains
.\"O .BR CLONE_NEWPID )
.\"O then the first element in the
.\"O .I set_tid
.\"O array has to be the desired PID and
.\"O .I set_tid_size
.\"O needs to be 1.
新しく作成されるプロセスの PID を、現在の PID 名前空間、または
.RI ( flags
に
.B CLONE_NEWPID
が含まれる場合) 新しく作成された PID 名前空間のみで設定する場合、
.I set_tid
配列の最初の要素が設定される PID になり、
.I set_tid_size
は 1 の必要がある。
.PP
.\"O If the PID of the newly created process should have a certain value in
.\"O multiple PID namespaces, then the
.\"O .I set_tid
.\"O array can have multiple entries.
新しく作成されるプロセスが、複数の PID 名前空間で特定の値を持つ場合、
.I set_tid
配列は複数の要素を含む必要がある。
.\"O The first entry defines the PID in the most
.\"O deeply nested PID namespace and each of the following entries contains
.\"O the PID in the
.\"O corresponding ancestor PID namespace.
最初の要素は、最も深く入れ子になった PID 名前空間での PID であり、
それ以降の要素は、祖先の PID 名前空間での PID に対応する。
.\"O The number of PID namespaces in which a PID
.\"O should be set is defined by
.\"O .I set_tid_size
.\"O which cannot be larger than the number of currently nested PID namespaces.
PID が設定される PID 名前空間の数は、
.I set_tid_size
で定義され、現在入れ子になっている PID 名前空間の数よりも大きくはできない。
.PP
.\"O To create a process with the following PIDs in a PID namespace hierarchy:
PID 名前空間の階層で、以下の PID を持つプロセスを作る場合:
.RS
.TS
lb lb lb
l l l.
.\"O PID NS level	Requested PID	Notes
PID NS レベル	要求される PID	注記
.\"O 0	31496	Outermost PID namespace
0	31496	一番外部の PID 名前空間
1	42
.\"O 2	7	Innermost PID namespace
2	7	一番内側の PID 名前空間
.TE
.RE
.PP
.\"O Set the array to:
配列を以下のようにする:
.PP
.in +4n
.EX
set_tid[0] = 7;
set_tid[1] = 42;
set_tid[2] = 31496;
set_tid_size = 3;
.EE
.in
.PP
.\"O If only the PIDs in the two innermost PID namespaces
.\"O need to be specified, set the array to:
内側から 2 つの PID 名前空間のみ指定が必要な場合、配列を以下のようにする:
.PP
.in +4n
.EX
set_tid[0] = 7;
set_tid[1] = 42;
set_tid_size = 2;
.EE
.in
.PP
.\"O The PID in the PID namespaces outside the two innermost PID namespaces
.\"O will be selected the same way as any other PID is selected.
内側から 2 つの PID 名前空間の外側にある PID 名前空間では、
PID は他の PID と同じ方法で選択される。
.PP
.\"O The
.\"O .I set_tid
.\"O feature requires
.\"O .BR CAP_SYS_ADMIN
.\"O in all owning user namespaces of the target PID namespaces.
.I set_tid
の機能を使うには、対象となる PID 名前空間を所有するすべてのユーザー名前空間で
.BR CAP_SYS_ADMIN
が必要である。
.PP
.\"O Callers may only choose a PID greater than 1 in a given PID namespace
.\"O if an
.\"O .BR init
.\"O process (i.e., a process with PID 1) already exists in that namespace.
.BR init
プロセス (つまり、PID 1 のプロセス) が指定された PID 名前空間に既に存在する場合、
呼び出し元は 1 より大きい PID のみを選択できる。
.\"O Otherwise the PID
.\"O entry for this PID namespace must be 1.
そうでない場合、その PID 名前空間の PID 要素は 1 でなければならない。
.\"
.\"O .SS The flags mask
.SS flags マスク
.PP
.\"O Both
.\"O .BR clone ()
.\"O and
.\"O .BR clone3 ()
.\"O allow a flags bit mask that modifies their behavior
.\"O and allows the caller to specify what is shared between the calling process
.\"O and the child process.
.BR clone ()
と
.BR clone3 ()
は、その挙動を変更する flags ビットマスクを使うことができる。
このフラグで呼び出し元のプロセスと子プロセスの間で何を共有するかを
指定できる。
.\"O This bit mask\(emthe
.\"O .I flags
.\"O argument of
.\"O .BR clone ()
.\"O or the
.\"O .I cl_args.flags
.\"O field passed to
.\"O .BR clone3 ()\(emis
.\"O referred to as the
.\"O .I flags
.\"O mask in the remainder of this page.
このビットマスク\(em
.BR clone ()
の
.I flags
引き数、または
.BR clone3 ()
に渡される
.I cl_args.flags
フィールド\(emは、
このページの残りで記載されている
.I flags
マスクを参照すること。
.PP
.\"O The
.\"O .I flags
.\"O mask is specified as a bitwise-OR of zero or more of
.\"O the constants listed below.
\fIflags\fP マスクには、以下の定数のうち 0 個以上の
ビット毎の論理和 (bitwise\-or) をとったものを指定できる。
.\"O Except as noted below, these flags are available
.\"O (and have the same effect) in both
.\"O .BR clone ()
.\"O and
.\"O .BR clone3 ().
下記の注記以外、これらのフラグは
.BR clone ()
と
.BR clone3 ()
の両方で利用可能である (かつ、同じ効果がある)。
.TP
.BR CLONE_CHILD_CLEARTID " (Linux 2.5.49 以降)"
.\"O .BR CLONE_CHILD_CLEARTID " (since Linux 2.5.49)"
.\"O Clear (zero) the child thread ID at the location pointed to by
.\"O .I child_tid
.\"O .RB ( clone ())
.\"O or
.\"O .I cl_args.child_tid
.\"O .RB ( clone3 ())
.\"O in child memory when the child exits, and do a wakeup on the futex
.\"O at that address.
子プロセスが終了したときに、子プロセスのメモリー内の
.RB ( clone ()
の場合)
.I child_tid
または
.RB ( clone3 ()
の場合)
.I cl_args.child_tid
が指す場所にある子プロセスのスレッド ID を消去し (0 にし)、
そのアドレスで futex を wakeup (起床) させる。
.\"O The address involved may be changed by the
.\"O .BR set_tid_address (2)
.\"O system call.
このアドレスは \fBset_tid_address\fP(2) システムコールで変更することができる。
.\"O This is used by threading libraries.
この機能はスレッドライブラリで使用される。
.TP
.BR CLONE_CHILD_SETTID " (Linux 2.5.49 以降)"
.\"O .BR CLONE_CHILD_SETTID " (since Linux 2.5.49)"
.\"O Store the child thread ID at the location pointed to by
.\"O .I child_tid
.\"O .RB ( clone ())
.\"O or
.\"O .I cl_args.child_tid
.\"O .RB ( clone3 ())
.\"O in the child's memory.
子プロセスのメモリー内の、
.RB ( clone ()
の場合)
.I child_tid
または
.RB ( clone3 ()
の場合)
.I cl_args.child_tid
が指す場所に子プロセスのスレッド ID を格納する。
.\"O The store operation completes before the clone call
.\"O returns control to user space in the child process.
格納の操作は、clone 呼び出しが子プロセスのユーザー空間に制御を返す前に、完了する。
.\"O (Note that the store operation may not have completed before the clone call
.\"O returns in the parent process, which will be relevant if the
.\"O .BR CLONE_VM
.\"O flag is also employed.)
(格納の操作は、clone 呼び出しが親プロセスに戻る前には完了しない。
これは
.BR CLONE_VM
フラグも設定されているかに関係する。)
.TP
.BR CLONE_CLEAR_SIGHAND " (Linux 5.5 以降)"
.\"O .BR CLONE_CLEAR_SIGHAND " (since Linux 5.5)"
.\" commit b612e5df4587c934bd056bf05f4a1deca4de4f75
.\"O By default, signal dispositions in the child thread are the same as
.\"O in the parent.
デフォルトでは、子スレッドのシグナルの処理方法 (disposition) は、親スレッドと同じである。
.\"O If this flag is specified,
.\"O then all signals that are handled in the parent
.\"O are reset to their default dispositions
.\"O .RB ( SIG_DFL )
.\"O in the child.
このフラグが設定された場合、
親スレッドで処理されるすべてのシグナルは、
子スレッドのデフォルトの処理方法
.RB ( SIG_DFL )
にリセットされる。
.IP
.\"O Specifying this flag together with
.\"O .B CLONE_SIGHAND
.\"O is nonsensical and disallowed.
このフラグを
.B CLONE_SIGHAND
と一緒に指定するのは、無意味であり、許可されていない。
.TP
.BR CLONE_DETACHED " (歴史的なフラグ)"
.\"O .BR CLONE_DETACHED " (historical)"
.\"O For a while (during the Linux 2.5 development series)
.\"O .\" added in 2.5.32; removed in 2.6.0-test4
.\"O there was a
.\"O .B CLONE_DETACHED
.\"O flag,
.\"O which caused the parent not to receive a signal when the child terminated.
(Linux 2.5 開発系列で) しばらくの間、
.B CLONE_DETACHED
フラグが存在した。
.\" 2.5.32 で追加され、2.6.0-test4 で削除された。
このフラグが指定されると、子プロセスが終了した時に、親プロセスは
シグナルを受信しない。
.\"O Ultimately, the effect of this flag was subsumed under the
.\"O .BR CLONE_THREAD
.\"O flag and by the time Linux 2.6.0 was released, this flag had no effect.
最終的に、このフラグの効果は、
.BR CLONE_THREAD
フラグに含まれるようになり、Linux 2.6.0 がリリースされた時点で、
このフラグは効果がなくなった。
.\"O Starting in Linux 2.6.2, the need to give this flag together with
.\"O .B CLONE_THREAD
.\"O disappeared.
Linux 2.6.2 以降では、このフラグを
.B CLONE_THREAD
と一緒に指定する必要はなくなった。
.IP
.\"O This flag is still defined, but it is usually ignored when calling
.\"O .BR clone ().
このフラグは、まだ定義されているが、
.BR clone ()
を呼び出す際には、通常は無視される。
.\"O However, see the description of
.\"O .BR CLONE_PIDFD
.\"O for some exceptions.
ただし、いくつかの例外については、
.BR CLONE_PIDFD
の説明を参照すること。
.TP
.BR CLONE_FILES " (Linux 2.0 以降)"
.\"O .BR CLONE_FILES " (since Linux 2.0)"
.\"O If
.\"O .B CLONE_FILES
.\"O is set, the calling process and the child process share the same file
.\"O descriptor table.
\fBCLONE_FILES\fP が設定された場合、呼び出し元のプロセスと子プロセスは
ファイルディスクリプターのテーブルを共有する。
.\"O Any file descriptor created by the calling process or by the child
.\"O process is also valid in the other process.
呼び出し元プロセスとその子プロセスの一方が作成したファイル
ディスクリプターは、もう一方においても有効である。
.\"O Similarly, if one of the processes closes a file descriptor,
.\"O or changes its associated flags (using the
.\"O .BR fcntl (2)
.\"O .B F_SETFD
.\"O operation), the other process is also affected.
同じように、一方のプロセスがファイルディスクリプターを閉じたり、
(\fBfcntl\fP(2) \fBF_SETFD\fP 操作を使って)
ディスクリプターに関連するフラグを変更したりすると、
もう一方のプロセスにも影響する。
.\"O If a process sharing a file descriptor table calls
.\"O .BR execve (2),
.\"O its file descriptor table is duplicated (unshared).
ファイルディスクリプターテーブルを共有するプロセスが、
.BR execve (2)
を呼び出すと、ファイルディスクリプターテーブルが (共有されず) 複製される。
.IP
.\"O If
.\"O .B CLONE_FILES
.\"O is not set, the child process inherits a copy of all file descriptors
.\"O opened in the calling process at the time of the clone call.
\fBCLONE_FILES\fP が設定されていない場合、子プロセスは、\fBclone\fP()
が実行された時点で、呼び出し元のプロセスがオープンしている全ての
ファイルディスクリプターのコピーを継承する。
.\"O Subsequent operations that open or close file descriptors,
.\"O or change file descriptor flags,
.\"O performed by either the calling
.\"O process or the child process do not affect the other process.
呼び出し元プロセス、もしくは子プロセスによって行われる、
ファイルディスクリプターのオープン・クローズ、
ファイルディスクリプターフラグの変更といった以降の操作は、
お互いのプロセスに影響を与えない。
.\"O Note, however,
.\"O that the duplicated file descriptors in the child refer to the same
.\"O open file descriptions as the corresponding file descriptors
.\"O in the calling process,
.\"O and thus share file offsets and file status flags (see
.\"O .BR open (2)).
ただし、子プロセスの複製されたファイルディスクリプターは、
呼び出し元プロセスでの対応するファイルディスクリプターとして、
同じオープンファイルディスクリプターを参照するので、
ファイルオフセットやファイルステータスフラグを共有する点に
注意すること
.RB ( open (2)
を参照)。
.TP
.BR CLONE_FS " (Linux 2.0 以降)"
.\"O .BR CLONE_FS " (since Linux 2.0)"
.\"O If
.\"O .B CLONE_FS
.\"O is set, the caller and the child process share the same filesystem
.\"O information.
\fBCLONE_FS\fP が設定された場合、呼び出し元のプロセスと子プロセスが同じ
ファイルシステム情報を共有する。
.\"O This includes the root of the filesystem, the current
.\"O working directory, and the umask.
ファイルシステム情報は、ファイルシステムのルート (root)、
カレントワーキングディレクトリ (current working directory) や umask などである。
.\"O Any call to
.\"O .BR chroot (2),
.\"O .BR chdir (2),
.\"O or
.\"O .BR umask (2)
.\"O performed by the calling process or the child process also affects the
.\"O other process.
呼び出し元のプロセスや子プロセスのどちらか一方によって \fBchroot\fP(2),
\fBchdir\fP(2), \fBumask\fP(2) が呼び出されると、もう一方のプロセスにも影響が及ぶ。
.IP
.\"O If
.\"O .B CLONE_FS
.\"O is not set, the child process works on a copy of the filesystem
.\"O information of the calling process at the time of the clone call.
\fBCLONE_FS\fP が設定されていない場合、子プロセスは、\fBclone\fP()
が実行された時点での、呼び出し元のプロセスのファイルシステム情報の
コピーを使用する。
.\"O Calls to
.\"O .BR chroot (2),
.\"O .BR chdir (2),
.\"O or
.\"O .BR umask (2)
.\"O performed later by one of the processes do not affect the other process.
これ以降は、呼び出し元のプロセスと子プロセスの一方が
\fBchroot\fP(2), \fBchdir\fP(2), \fBumask\fP(2) を呼び出しても、
もう一方のプロセスには影響を与えない。
.TP
.BR CLONE_INTO_CGROUP " (Linux 5.7 以降)"
.\"O .BR CLONE_INTO_CGROUP " (since Linux 5.7)"
.\" commit ef2c41cf38a7559bbf91af42d5b6a4429db8fc68
.\"O By default, a child process is placed in the same version 2
.\"O cgroup as its parent.
デフォルトでは、子プロセスは、親プロセスと同じバージョン 2 cgroup に置かれる。
.\"O The
.\"O .B CLONE_INTO_CGROUP
.\"O flag allows the child process to be created in a different version 2 cgroup.
.B CLONE_INTO_CGROUP
フラグを指定すると、子プロセスを別のバージョン 2 cgroup に作成することができる。
.\"O (Note that
.\"O .BR CLONE_INTO_CGROUP
.\"O has effect only for version 2 cgroups.)
.RB ( CLONE_INTO_CGROUP
はバージョン 2 cgroup にしか効果がない点に注意すること。)
.IP
.\"O In order to place the child process in a different cgroup,
.\"O the caller specifies
.\"O .BR CLONE_INTO_CGROUP
.\"O in
.\"O .I cl_args.flags
.\"O and passes a file descriptor that refers to a version 2 cgroup in the
.\"O .I cl_args.cgroup
.\"O field.
子プロセスを別の cgroup に置くためには、
呼び出し元が
.BR CLONE_INTO_CGROUP
を
.I cl_args.flags
に指定し、バージョン 2 cgroup を参照するファイルディスクリプターを
.I cl_args.cgroup
フィールドに渡す必要がある。
.\"O (This file descriptor can be obtained by opening a cgroup v2 directory
.\"O using either the
.\"O .B O_RDONLY
.\"O or the
.\"O .B O_PATH
.\"O flag.)
(このファイルディスクリプターは、cgroup v2 ディレクトリを
.B O_RDONLY
または
.B O_PATH
フラグでオープンすることで取得できる。)
.\"O Note that all of the usual restrictions (described in
.\"O .BR cgroups (7))
.\"O on placing a process into a version 2 cgroup apply.
.RB ( cgroups (7)
に記述されている) すべての一般的な制限が、
プロセスをバージョン 2 cgroup に置く際に適用される点に注意すること。
.IP
.\"O Among the possible use cases for
.\"O .BR CLONE_INTO_CGROUP
.\"O are the following:
.BR CLONE_INTO_CGROUP
を使う可能性のある使用例は以下の通りである:
.RS
.IP * 3
Spawning a process into a cgroup different from the parent's cgroup
makes it possible for a service manager to directly spawn new
services into dedicated cgroups.
This eliminates the accounting
jitter that would be caused if the child process was first created in the
same cgroup as the parent and then
moved into the target cgroup.
Furthermore, spawning the child process directly into a target cgroup
is significantly cheaper than moving the child process into
the target cgroup after it has been created.
.IP *
The
.BR CLONE_INTO_CGROUP
flag also allows the creation of
frozen child processes by spawning them into a frozen cgroup.
(See
.BR cgroups (7)
for a description of the freezer controller.)
.IP *
For threaded applications (or even thread implementations which
make use of cgroups to limit individual threads), it is possible to
establish a fixed cgroup layout before spawning each thread
directly into its target cgroup.
.RE
.TP
.BR CLONE_IO " (since Linux 2.6.25)"
If
.B CLONE_IO
is set, then the new process shares an I/O context with
the calling process.
If this flag is not set, then (as with
.BR fork (2))
the new process has its own I/O context.
.IP
.\" The following based on text from Jens Axboe
The I/O context is the I/O scope of the disk scheduler (i.e.,
what the I/O scheduler uses to model scheduling of a process's I/O).
If processes share the same I/O context,
they are treated as one by the I/O scheduler.
As a consequence, they get to share disk time.
For some I/O schedulers,
.\" the anticipatory and CFQ scheduler
if two processes share an I/O context,
they will be allowed to interleave their disk access.
If several threads are doing I/O on behalf of the same process
.RB ( aio_read (3),
for instance), they should employ
.BR CLONE_IO
to get better I/O performance.
.\" with CFQ and AS.
.IP
If the kernel is not configured with the
.B CONFIG_BLOCK
option, this flag is a no-op.
.TP
.BR CLONE_NEWCGROUP " (since Linux 4.6)"
Create the process in a new cgroup namespace.
If this flag is not set, then (as with
.BR fork (2))
the process is created in the same cgroup namespaces as the calling process.
.IP
For further information on cgroup namespaces, see
.BR cgroup_namespaces (7).
.IP
Only a privileged process
.RB ( CAP_SYS_ADMIN )
can employ
.BR CLONE_NEWCGROUP .
.\"
.TP
.BR CLONE_NEWIPC " (since Linux 2.6.19)"
If
.B CLONE_NEWIPC
is set, then create the process in a new IPC namespace.
If this flag is not set, then (as with
.BR fork (2)),
the process is created in the same IPC namespace as
the calling process.
.IP
For further information on IPC namespaces, see
.BR ipc_namespaces (7).
.IP
Only a privileged process
.RB ( CAP_SYS_ADMIN )
can employ
.BR CLONE_NEWIPC .
This flag can't be specified in conjunction with
.BR CLONE_SYSVSEM .
.TP
.BR CLONE_NEWNET " (since Linux 2.6.24)"
(The implementation of this flag was completed only
by about kernel version 2.6.29.)
.IP
If
.B CLONE_NEWNET
is set, then create the process in a new network namespace.
If this flag is not set, then (as with
.BR fork (2))
the process is created in the same network namespace as
the calling process.
.IP
For further information on network namespaces, see
.BR network_namespaces (7).
.IP
Only a privileged process
.RB ( CAP_SYS_ADMIN )
can employ
.BR CLONE_NEWNET .
.TP
.BR CLONE_NEWNS " (since Linux 2.4.19)"
If
.B CLONE_NEWNS
is set, the cloned child is started in a new mount namespace,
initialized with a copy of the namespace of the parent.
If
.B CLONE_NEWNS
is not set, the child lives in the same mount
namespace as the parent.
.IP
For further information on mount namespaces, see
.BR namespaces (7)
and
.BR mount_namespaces (7).
.IP
Only a privileged process
.RB ( CAP_SYS_ADMIN )
can employ
.BR CLONE_NEWNS .
It is not permitted to specify both
.B CLONE_NEWNS
and
.B CLONE_FS
.\" See https://lwn.net/Articles/543273/
in the same clone call.
.TP
.BR CLONE_NEWPID " (since Linux 2.6.24)"
.\" This explanation draws a lot of details from
.\" http://lwn.net/Articles/259217/
.\" Authors: Pavel Emelyanov <xemul@openvz.org>
.\" and Kir Kolyshkin <kir@openvz.org>
.\"
.\" The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
.\" Author: Pavel Emelyanov <xemul@openvz.org>
If
.B CLONE_NEWPID
is set, then create the process in a new PID namespace.
If this flag is not set, then (as with
.BR fork (2))
the process is created in the same PID namespace as
the calling process.
.IP
For further information on PID namespaces, see
.BR namespaces (7)
and
.BR pid_namespaces (7).
.IP
Only a privileged process
.RB ( CAP_SYS_ADMIN )
can employ
.BR CLONE_NEWPID .
This flag can't be specified in conjunction with
.BR CLONE_THREAD
or
.BR CLONE_PARENT .
.TP
.BR CLONE_NEWUSER
(This flag first became meaningful for
.BR clone ()
in Linux 2.6.23,
the current
.BR clone ()
semantics were merged in Linux 3.5,
and the final pieces to make the user namespaces completely usable were
merged in Linux 3.8.)
.IP
If
.B CLONE_NEWUSER
is set, then create the process in a new user namespace.
If this flag is not set, then (as with
.BR fork (2))
the process is created in the same user namespace as the calling process.
.IP
For further information on user namespaces, see
.BR namespaces (7)
and
.BR user_namespaces (7).
.IP
Before Linux 3.8, use of
.BR CLONE_NEWUSER
required that the caller have three capabilities:
.BR CAP_SYS_ADMIN ,
.BR CAP_SETUID ,
and
.BR CAP_SETGID .
.\" Before Linux 2.6.29, it appears that only CAP_SYS_ADMIN was needed
Starting with Linux 3.8,
no privileges are needed to create a user namespace.
.IP
This flag can't be specified in conjunction with
.BR CLONE_THREAD
or
.BR CLONE_PARENT .
For security reasons,
.\" commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
.\" https://lwn.net/Articles/543273/
.\" The fix actually went into 3.9 and into 3.8.3. However, user namespaces
.\" were, for practical purposes, unusable in earlier 3.8.x because of the
.\" various filesystems that didn't support userns.
.BR CLONE_NEWUSER
cannot be specified in conjunction with
.BR CLONE_FS .
.TP
.BR CLONE_NEWUTS " (since Linux 2.6.19)"
If
.B CLONE_NEWUTS
is set, then create the process in a new UTS namespace,
whose identifiers are initialized by duplicating the identifiers
from the UTS namespace of the calling process.
If this flag is not set, then (as with
.BR fork (2))
the process is created in the same UTS namespace as
the calling process.
.IP
For further information on UTS namespaces, see
.BR uts_namespaces (7).
.IP
Only a privileged process
.RB ( CAP_SYS_ADMIN )
can employ
.BR CLONE_NEWUTS .
.TP
.BR CLONE_PARENT " (since Linux 2.3.12)"
If
.B CLONE_PARENT
is set, then the parent of the new child (as returned by
.BR getppid (2))
will be the same as that of the calling process.
.IP
If
.B CLONE_PARENT
is not set, then (as with
.BR fork (2))
the child's parent is the calling process.
.IP
Note that it is the parent process, as returned by
.BR getppid (2),
which is signaled when the child terminates, so that
if
.B CLONE_PARENT
is set, then the parent of the calling process, rather than the
calling process itself, will be signaled.
.IP
The
.B CLONE_PARENT
flag can't be used in clone calls by the
global init process (PID 1 in the initial PID namespace)
and init processes in other PID namespaces.
This restriction prevents the creation of multi-rooted process trees
as well as the creation of unreapable zombies in the initial PID namespace.
.TP
.BR CLONE_PARENT_SETTID " (since Linux 2.5.49)"
Store the child thread ID at the location pointed to by
.I parent_tid
.RB ( clone ())
or
.I cl_args.parent_tid
.RB ( clone3 ())
in the parent's memory.
(In Linux 2.5.32-2.5.48 there was a flag
.B CLONE_SETTID
that did this.)
The store operation completes before the clone call
returns control to user space.
.TP
.BR CLONE_PID " (Linux 2.0 to 2.5.15)"
If
.B CLONE_PID
is set, the child process is created with the same process ID as
the calling process.
This is good for hacking the system, but otherwise
of not much use.
From Linux 2.3.21 onward, this flag could be
specified only by the system boot process (PID 0).
The flag disappeared completely from the kernel sources in Linux 2.5.16.
Subsequently, the kernel silently ignored this bit if it was specified in the
.IR flags
mask.
Much later, the same bit was recycled for use as the
.B CLONE_PIDFD
flag.
.TP
.BR CLONE_PIDFD " (since Linux 5.2)"
.\" commit b3e5838252665ee4cfa76b82bdf1198dca81e5be
If this flag is specified,
a PID file descriptor referring to the child process is allocated
and placed at a specified location in the parent's memory.
The close-on-exec flag is set on this new file descriptor.
PID file descriptors can be used for the purposes described in
.BR pidfd_open (2).
.RS
.IP * 3
When using
.BR clone3 (),
the PID file descriptor is placed at the location pointed to by
.IR cl_args.pidfd .
.IP *
When using
.BR clone (),
the PID file descriptor is placed at the location pointed to by
.IR parent_tid .
Since the
.I parent_tid
argument is used to return the PID file descriptor,
.B CLONE_PIDFD
cannot be used with
.B CLONE_PARENT_SETTID
when calling
.BR clone ().
.RE
.IP
It is currently not possible to use this flag together with
.B CLONE_THREAD.
This means that the process identified by the PID file descriptor
will always be a thread group leader.
.IP
If the obsolete
.B CLONE_DETACHED
flag is specified alongside
.BR CLONE_PIDFD
when calling
.BR clone (),
an error is returned.
An error also results if
.B CLONE_DETACHED
is specified when calling
.BR clone3 ().
This error behavior ensures that the bit corresponding to
.BR CLONE_DETACHED
can be reused for further PID file descriptor features in the future.
.TP
.BR CLONE_PTRACE " (since Linux 2.2)"
If
.B CLONE_PTRACE
is specified, and the calling process is being traced,
then trace the child also (see
.BR ptrace (2)).
.TP
.BR CLONE_SETTLS " (since Linux 2.5.32)"
The TLS (Thread Local Storage) descriptor is set to
.IR tls .
.IP
The interpretation of
.I tls
and the resulting effect is architecture dependent.
On x86,
.I tls
is interpreted as a
.IR "struct user_desc\ *"
(see
.BR set_thread_area (2)).
On x86-64 it is the new value to be set for the %fs base register
(see the
.B ARCH_SET_FS
argument to
.BR arch_prctl (2)).
On architectures with a dedicated TLS register, it is the new value
of that register.
.IP
Use of this flag requires detailed knowledge and generally it
should not be used except in libraries implementing threading.
.TP
.BR CLONE_SIGHAND " (since Linux 2.0)"
If
.B CLONE_SIGHAND
is set, the calling process and the child process share the same table of
signal handlers.
If the calling process or child process calls
.BR sigaction (2)
to change the behavior associated with a signal, the behavior is
changed in the other process as well.
However, the calling process and child
processes still have distinct signal masks and sets of pending
signals.
So, one of them may block or unblock signals using
.BR sigprocmask (2)
without affecting the other process.
.IP
If
.B CLONE_SIGHAND
is not set, the child process inherits a copy of the signal handlers
of the calling process at the time of the clone call.
Calls to
.BR sigaction (2)
performed later by one of the processes have no effect on the other
process.
.IP
Since Linux 2.6.0,
.\" Precisely: Linux 2.6.0-test6
the
.I flags
mask must also include
.B CLONE_VM
if
.B CLONE_SIGHAND
is specified
.TP
.BR CLONE_STOPPED " (since Linux 2.6.0)"
.\" Precisely: Linux 2.6.0-test2
If
.B CLONE_STOPPED
is set, then the child is initially stopped (as though it was sent a
.B SIGSTOP
signal), and must be resumed by sending it a
.B SIGCONT
signal.
.IP
This flag was
.I deprecated
from Linux 2.6.25 onward,
and was
.I removed
altogether in Linux 2.6.38.
Since then, the kernel silently ignores it without error.
.\" glibc 2.8 removed this defn from bits/sched.h
Starting with Linux 4.6, the same bit was reused for the
.BR CLONE_NEWCGROUP
flag.
.TP
.BR CLONE_SYSVSEM " (since Linux 2.5.10)"
If
.B CLONE_SYSVSEM
is set, then the child and the calling process share
a single list of System V semaphore adjustment
.RI ( semadj )
values (see
.BR semop (2)).
In this case, the shared list accumulates
.I semadj
values across all processes sharing the list,
and semaphore adjustments are performed only when the last process
that is sharing the list terminates (or ceases sharing the list using
.BR unshare (2)).
If this flag is not set, then the child has a separate
.I semadj
list that is initially empty.
.TP
.BR CLONE_THREAD " (since Linux 2.4.0)"
.\" Precisely: Linux 2.6.0-test8
If
.B CLONE_THREAD
is set, the child is placed in the same thread group as the calling process.
To make the remainder of the discussion of
.B CLONE_THREAD
more readable, the term "thread" is used to refer to the
processes within a thread group.
.IP
Thread groups were a feature added in Linux 2.4 to support the
POSIX threads notion of a set of threads that share a single PID.
Internally, this shared PID is the so-called
thread group identifier (TGID) for the thread group.
Since Linux 2.4, calls to
.BR getpid (2)
return the TGID of the caller.
.IP
The threads within a group can be distinguished by their (system-wide)
unique thread IDs (TID).
A new thread's TID is available as the function result
returned to the caller,
and a thread can obtain
its own TID using
.BR gettid (2).
.IP
When a clone call is made without specifying
.BR CLONE_THREAD ,
then the resulting thread is placed in a new thread group
whose TGID is the same as the thread's TID.
This thread is the
.I leader
of the new thread group.
.IP
A new thread created with
.B CLONE_THREAD
has the same parent process as the process that made the clone call
(i.e., like
.BR CLONE_PARENT ),
so that calls to
.BR getppid (2)
return the same value for all of the threads in a thread group.
When a
.B CLONE_THREAD
thread terminates, the thread that created it is not sent a
.B SIGCHLD
(or other termination) signal;
nor can the status of such a thread be obtained
using
.BR wait (2).
(The thread is said to be
.IR detached .)
.IP
After all of the threads in a thread group terminate
the parent process of the thread group is sent a
.B SIGCHLD
(or other termination) signal.
.IP
If any of the threads in a thread group performs an
.BR execve (2),
then all threads other than the thread group leader are terminated,
and the new program is executed in the thread group leader.
.IP
If one of the threads in a thread group creates a child using
.BR fork (2),
then any thread in the group can
.BR wait (2)
for that child.
.IP
Since Linux 2.5.35, the
.I flags
mask must also include
.B CLONE_SIGHAND
if
.B CLONE_THREAD
is specified
(and note that, since Linux 2.6.0,
.\" Precisely: Linux 2.6.0-test6
.BR CLONE_SIGHAND
also requires
.BR CLONE_VM
to be included).
.IP
Signal dispositions and actions are process-wide:
if an unhandled signal is delivered to a thread, then
it will affect (terminate, stop, continue, be ignored in)
all members of the thread group.
.IP
Each thread has its own signal mask, as set by
.BR sigprocmask (2).
.IP
A signal may be process-directed or thread-directed.
A process-directed signal is targeted at a thread group (i.e., a TGID),
and is delivered to an arbitrarily selected thread from among those
that are not blocking the signal.
A signal may be process-directed because it was generated by the kernel
for reasons other than a hardware exception, or because it was sent using
.BR kill (2)
or
.BR sigqueue (3).
A thread-directed signal is targeted at (i.e., delivered to)
a specific thread.
A signal may be thread directed because it was sent using
.BR tgkill (2)
or
.BR pthread_sigqueue (3),
or because the thread executed a machine language instruction that triggered
a hardware exception
(e.g., invalid memory access triggering
.BR SIGSEGV
or a floating-point exception triggering
.BR SIGFPE ).
.IP
A call to
.BR sigpending (2)
returns a signal set that is the union of the pending process-directed
signals and the signals that are pending for the calling thread.
.IP
If a process-directed signal is delivered to a thread group,
and the thread group has installed a handler for the signal, then
the handler will be invoked in exactly one, arbitrarily selected
member of the thread group that has not blocked the signal.
If multiple threads in a group are waiting to accept the same signal using
.BR sigwaitinfo (2),
the kernel will arbitrarily select one of these threads
to receive the signal.
.TP
.BR CLONE_UNTRACED " (since Linux 2.5.46)"
If
.B CLONE_UNTRACED
is specified, then a tracing process cannot force
.B CLONE_PTRACE
on this child process.
.TP
.BR CLONE_VFORK " (since Linux 2.2)"
If
.B CLONE_VFORK
is set, the execution of the calling process is suspended
until the child releases its virtual memory
resources via a call to
.BR execve (2)
or
.BR _exit (2)
(as with
.BR vfork (2)).
.IP
If
.B CLONE_VFORK
is not set, then both the calling process and the child are schedulable
after the call, and an application should not rely on execution occurring
in any particular order.
.TP
.BR CLONE_VM " (since Linux 2.0)"
If
.B CLONE_VM
is set, the calling process and the child process run in the same memory
space.
In particular, memory writes performed by the calling process
or by the child process are also visible in the other process.
Moreover, any memory mapping or unmapping performed with
.BR mmap (2)
or
.BR munmap (2)
by the child or calling process also affects the other process.
.IP
If
.B CLONE_VM
is not set, the child process runs in a separate copy of the memory
space of the calling process at the time of the clone call.
Memory writes or file mappings/unmappings performed by one of the
processes do not affect the other, as with
.BR fork (2).
.SH RETURN VALUE
.\" gettid(2) returns current->pid;
.\" getpid(2) returns current->tgid;
On success, the thread ID of the child process is returned
in the caller's thread of execution.
On failure, \-1 is returned
in the caller's context, no child process will be created, and
.I errno
will be set appropriately.
.SH ERRORS
.TP
.B EAGAIN
Too many processes are already running; see
.BR fork (2).
.TP
.BR EBUSY " (" clone3 "() only)"
.B CLONE_INTO_CGROUP
was specified in
.IR cl_args.flags ,
but the file descriptor specified in
.IR cl_args.cgroup
refers to a version 2 cgroup in which a domain controller is enabled.
.TP
.BR EEXIST " (" clone3 "() only)"
One (or more) of the PIDs specified in
.I set_tid
already exists in the corresponding PID namespace.
.TP
.B EINVAL
Both
.B CLONE_SIGHAND
and
.B CLONE_CLEAR_SIGHAND
were specified in the
.I flags
mask.
.TP
.B EINVAL
.B CLONE_SIGHAND
was specified in the
.I flags
mask, but
.B CLONE_VM
was not.
(Since Linux 2.6.0.)
.\" Precisely: Linux 2.6.0-test6
.TP
.B EINVAL
.B CLONE_THREAD
was specified in the
.I flags
mask, but
.B CLONE_SIGHAND
was not.
(Since Linux 2.5.35.)
.\" .TP
.\" .B EINVAL
.\" Precisely one of
.\" .B CLONE_DETACHED
.\" and
.\" .B CLONE_THREAD
.\" was specified.
.\" (Since Linux 2.6.0-test6.)
.TP
.B EINVAL
.B CLONE_THREAD
was specified in the
.I flags
mask, but the current process previously called
.BR unshare (2)
with the
.B CLONE_NEWPID
flag or used
.BR setns (2)
to reassociate itself with a PID namespace.
.TP
.B EINVAL
.\" commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
Both
.B CLONE_FS
and
.B CLONE_NEWNS
were specified in the
.IR flags
mask.
.TP
.BR EINVAL " (since Linux 3.9)"
Both
.B CLONE_NEWUSER
and
.B CLONE_FS
were specified in the
.IR flags
mask.
.TP
.B EINVAL
Both
.B CLONE_NEWIPC
and
.B CLONE_SYSVSEM
were specified in the
.IR flags
mask.
.TP
.B EINVAL
One (or both) of
.BR CLONE_NEWPID
or
.BR CLONE_NEWUSER
and one (or both) of
.BR CLONE_THREAD
or
.BR CLONE_PARENT
were specified in the
.IR flags
mask.
.TP
.BR EINVAL " (since Linux 2.6.32)"
.\" commit 123be07b0b399670a7cc3d82fef0cb4f93ef885c
.BR CLONE_PARENT
was specified, and the caller is an init process.
.TP
.B EINVAL
Returned by the glibc
.BR clone ()
wrapper function when
.IR fn
or
.IR stack
is specified as NULL.
.TP
.B EINVAL
.BR CLONE_NEWIPC
was specified in the
.IR flags
mask,
but the kernel was not configured with the
.B CONFIG_SYSVIPC
and
.BR CONFIG_IPC_NS
options.
.TP
.B EINVAL
.BR CLONE_NEWNET
was specified in the
.IR flags
mask,
but the kernel was not configured with the
.B CONFIG_NET_NS
option.
.TP
.B EINVAL
.BR CLONE_NEWPID
was specified in the
.IR flags
mask,
but the kernel was not configured with the
.B CONFIG_PID_NS
option.
.TP
.B EINVAL
.BR CLONE_NEWUSER
was specified in the
.IR flags
mask,
but the kernel was not configured with the
.B CONFIG_USER_NS
option.
.TP
.B EINVAL
.BR CLONE_NEWUTS
was specified in the
.IR flags
mask,
but the kernel was not configured with the
.B CONFIG_UTS_NS
option.
.TP
.B EINVAL
.I stack
is not aligned to a suitable boundary for this architecture.
For example, on aarch64,
.I stack
must be a multiple of 16.
.TP
.BR EINVAL " (" clone3 "() only)"
.B  CLONE_DETACHED
was specified in the
.I flags
mask.
.TP
.BR EINVAL " (" clone "() only)"
.B CLONE_PIDFD
was specified together with
.B CLONE_DETACHED
in the
.I flags
mask.
.TP
.B EINVAL
.B CLONE_PIDFD
was specified together with
.B CLONE_THREAD
in the
.I flags
mask.
.TP
.BR "EINVAL " "("  clone "() only)"
.B CLONE_PIDFD
was specified together with
.B CLONE_PARENT_SETTID
in the
.I flags
mask.
.TP
.BR EINVAL " (" clone3 "() only)"
.I set_tid_size
is greater than the number of nested PID namespaces.
.TP
.BR EINVAL " (" clone3 "() only)"
One of the PIDs specified in
.I set_tid
was an invalid.
.TP
.BR EINVAL " (AArch64 only, Linux 4.6 and earlier)"
.I stack
was not aligned to a 126-bit boundary.
.TP
.B ENOMEM
Cannot allocate sufficient memory to allocate a task structure for the
child, or to copy those parts of the caller's context that need to be
copied.
.TP
.BR ENOSPC " (since Linux 3.7)"
.\" commit f2302505775fd13ba93f034206f1e2a587017929
.B CLONE_NEWPID
was specified in the
.I flags
mask,
but the limit on the nesting depth of PID namespaces
would have been exceeded; see
.BR pid_namespaces (7).
.TP
.BR ENOSPC " (since Linux 4.9; beforehand " EUSERS )
.B CLONE_NEWUSER
was specified in the
.IR flags
mask, and the call would cause the limit on the number of
nested user namespaces to be exceeded.
See
.BR user_namespaces (7).
.IP
From Linux 3.11 to Linux 4.8, the error diagnosed in this case was
.BR EUSERS .
.TP
.BR ENOSPC " (since Linux 4.9)"
One of the values in the
.I flags
mask specified the creation of a new user namespace,
but doing so would have caused the limit defined by the corresponding file in
.IR /proc/sys/user
to be exceeded.
For further details, see
.BR namespaces (7).
.TP
.BR EOPNOTSUP " (" clone3 "() only)"
.B CLONE_INTO_CGROUP
was specified in
.IR cl_args.flags ,
but the file descriptor specified in
.IR cl_args.cgroup
refers to a version 2 cgroup that is in the
.IR "domain invalid"
state.
.TP
.B EPERM
.BR CLONE_NEWCGROUP ,
.BR CLONE_NEWIPC ,
.BR CLONE_NEWNET ,
.BR CLONE_NEWNS ,
.BR CLONE_NEWPID ,
or
.BR CLONE_NEWUTS
was specified by an unprivileged process (process without \fBCAP_SYS_ADMIN\fP).
.TP
.B EPERM
.B CLONE_PID
was specified by a process other than process 0.
(This error occurs only on Linux 2.5.15 and earlier.)
.TP
.B EPERM
.BR CLONE_NEWUSER
was specified in the
.IR flags
mask,
but either the effective user ID or the effective group ID of the caller
does not have a mapping in the parent namespace (see
.BR user_namespaces (7)).
.TP
.BR EPERM " (since Linux 3.9)"
.\" commit 3151527ee007b73a0ebd296010f1c0454a919c7d
.B CLONE_NEWUSER
was specified in the
.I flags
mask and the caller is in a chroot environment
.\" FIXME What is the rationale for this restriction?
(i.e., the caller's root directory does not match the root directory
of the mount namespace in which it resides).
.TP
.BR EPERM " (" clone3 "() only)"
.I set_tid_size
was greater than zero, and the caller lacks the
.B CAP_SYS_ADMIN
capability in one or more of the user namespaces that own the
corresponding PID namespaces.
.TP
.BR ERESTARTNOINTR " (since Linux 2.6.17)"
.\" commit 4a2c7a7837da1b91468e50426066d988050e4d56
System call was interrupted by a signal and will be restarted.
(This can be seen only during a trace.)
.TP
.BR EUSERS " (Linux 3.11 to Linux 4.8)"
.B CLONE_NEWUSER
was specified in the
.IR flags
mask,
and the limit on the number of nested user namespaces would be exceeded.
See the discussion of the
.BR ENOSPC
error above.
.SH VERSIONS
The
.BR clone3 ()
system call first appeared in Linux 5.3.
.\" There is no entry for
.\" .BR clone ()
.\" in libc5.
.\" glibc2 provides
.\" .BR clone ()
.\" as described in this manual page.
.SH CONFORMING TO
These system calls
are Linux-specific and should not be used in programs
intended to be portable.
.SH NOTES
.PP
One use of these systems calls
is to implement threads: multiple flows of control in a program that
run concurrently in a shared address space.
.PP
Glibc does not provide a wrapper for
.BR clone3 ();
call it using
.BR syscall (2).
.PP
Note that the glibc
.BR clone ()
wrapper function makes some changes
in the memory pointed to by
.I stack
(changes required to set the stack up correctly for the child)
.I before
invoking the
.BR clone ()
system call.
So, in cases where
.BR clone ()
is used to recursively create children,
do not use the buffer employed for the parent's stack
as the stack of the child.
.PP
The
.BR kcmp (2)
system call can be used to test whether two processes share various
resources such as a file descriptor table,
System V semaphore undo operations, or a virtual address space.
.PP
.PP
Handlers registered using
.BR pthread_atfork (3)
are not executed during a clone call.
.PP
In the Linux 2.4.x series,
.B CLONE_THREAD
generally does not make the parent of the new thread the same
as the parent of the calling process.
However, for kernel versions 2.4.7 to 2.4.18 the
.B CLONE_THREAD
flag implied the
.B CLONE_PARENT
flag (as in Linux 2.6.0 and later).
.PP
On i386,
.BR clone ()
should not be called through vsyscall, but directly through
.IR "int $0x80" .
.\"
.SS C library/kernel differences
The raw
.BR clone ()
system call corresponds more closely to
.BR fork (2)
in that execution in the child continues from the point of the
call.
As such, the
.I fn
and
.I arg
arguments of the
.BR clone ()
wrapper function are omitted.
.PP
In contrast to the glibc wrapper, the raw
.BR clone ()
system call accepts NULL as a
.I stack
argument (and
.BR clone3 ()
likewise allows
.I cl_args.stack
to be NULL).
In this case, the child uses a duplicate of the parent's stack.
(Copy-on-write semantics ensure that the child gets separate copies
of stack pages when either process modifies the stack.)
In this case, for correct operation, the
.B CLONE_VM
option should not be specified.
(If the child
.I shares
the parent's memory because of the use of the
.BR CLONE_VM
flag,
then no copy-on-write duplication occurs and chaos is likely to result.)
.PP
The order of the arguments also differs in the raw system call,
and there are variations in the arguments across architectures,
as detailed in the following paragraphs.
.PP
The raw system call interface on x86-64 and some other architectures
(including sh, tile, and alpha) is:
.PP
.in +4
.EX
.BI "long clone(unsigned long " flags ", void *" stack ,
.BI "           int *" parent_tid ", int *" child_tid ,
.BI "           unsigned long " tls );
.EE
.in
.PP
On x86-32, and several other common architectures
(including score, ARM, ARM 64, PA-RISC, arc, Power PC, xtensa,
and MIPS),
.\" CONFIG_CLONE_BACKWARDS
the order of the last two arguments is reversed:
.PP
.in +4
.EX
.BI "long clone(unsigned long " flags ", void *" stack ,
.BI "          int *" parent_tid ", unsigned long " tls ,
.BI "          int *" child_tid );
.EE
.in
.PP
On the cris and s390 architectures,
.\" CONFIG_CLONE_BACKWARDS2
the order of the first two arguments is reversed:
.PP
.in +4
.EX
.BI "long clone(void *" stack ", unsigned long " flags ,
.BI "           int *" parent_tid ", int *" child_tid ,
.BI "           unsigned long " tls );
.EE
.in
.PP
On the microblaze architecture,
.\" CONFIG_CLONE_BACKWARDS3
an additional argument is supplied:
.PP
.in +4
.EX
.BI "long clone(unsigned long " flags ", void *" stack ,
.BI "           int " stack_size , "\fR         /* Size of stack */"
.BI "           int *" parent_tid ", int *" child_tid ,
.BI "           unsigned long " tls );
.EE
.in
.\"
.SS blackfin, m68k, and sparc
.\" Mike Frysinger noted in a 2013 mail:
.\"     these arches don't define __ARCH_WANT_SYS_CLONE:
.\"     blackfin ia64 m68k sparc
The argument-passing conventions on
blackfin, m68k, and sparc are different from the descriptions above.
For details, see the kernel (and glibc) source.
.SS ia64
On ia64, a different interface is used:
.PP
.in +4
.EX
.BI "int __clone2(int (*" "fn" ")(void *), "
.BI "             void *" stack_base ", size_t " stack_size ,
.BI "             int " flags ", void *" "arg" ", ... "
.BI "          /* pid_t *" parent_tid ", struct user_desc *" tls ,
.BI "             pid_t *" child_tid " */ );"
.EE
.in
.PP
The prototype shown above is for the glibc wrapper function;
for the system call itself,
the prototype can be described as follows (it is identical to the
.BR clone ()
prototype on microblaze):
.PP
.in +4
.EX
.BI "long clone2(unsigned long " flags ", void *" stack_base ,
.BI "            int " stack_size , "\fR         /* Size of stack */"
.BI "            int *" parent_tid ", int *" child_tid ,
.BI "            unsigned long " tls );
.EE
.in
.PP
.BR __clone2 ()
operates in the same way as
.BR clone (),
except that
.I stack_base
points to the lowest address of the child's stack area,
and
.I stack_size
specifies the size of the stack pointed to by
.IR stack_base .
.SS Linux 2.4 and earlier
In Linux 2.4 and earlier,
.BR clone ()
does not take arguments
.IR parent_tid ,
.IR tls ,
and
.IR child_tid .
.SH BUGS
GNU C library versions 2.3.4 up to and including 2.24
contained a wrapper function for
.BR getpid (2)
that performed caching of PIDs.
This caching relied on support in the glibc wrapper for
.BR clone (),
but limitations in the implementation
meant that the cache was not up to date in some circumstances.
In particular,
if a signal was delivered to the child immediately after the
.BR clone ()
call, then a call to
.BR getpid (2)
in a handler for the signal could return the PID
of the calling process ("the parent"),
if the clone wrapper had not yet had a chance to update the PID
cache in the child.
(This discussion ignores the case where the child was created using
.BR CLONE_THREAD ,
when
.BR getpid (2)
.I should
return the same value in the child and in the process that called
.BR clone (),
since the caller and the child are in the same thread group.
The stale-cache problem also does not occur if the
.I flags
argument includes
.BR CLONE_VM .)
To get the truth, it was sometimes necessary to use code such as the following:
.PP
.in +4n
.EX
#include <syscall.h>

pid_t mypid;

mypid = syscall(SYS_getpid);
.EE
.in
.\" See also the following bug reports
.\" https://bugzilla.redhat.com/show_bug.cgi?id=417521
.\" http://sourceware.org/bugzilla/show_bug.cgi?id=6910
.PP
Because of the stale-cache problem, as well as other problems noted in
.BR getpid (2),
the PID caching feature was removed in glibc 2.25.
.SH EXAMPLES
The following program demonstrates the use of
.BR clone ()
to create a child process that executes in a separate UTS namespace.
The child changes the hostname in its UTS namespace.
Both parent and child then display the system hostname,
making it possible to see that the hostname
differs in the UTS namespaces of the parent and child.
For an example of the use of this program, see
.BR setns (2).
.PP
Within the sample program, we allocate the memory that is to
be used for the child's stack using
.BR mmap (2)
rather than
.BR malloc (3)
for the following reasons:
.IP * 3
.BR mmap (2)
allocates a block of memory that starts on a page
boundary and is a multiple of the page size.
This is useful if we want to establish a guard page (a page with protection
.BR PROT_NONE )
at the end of the stack using
.BR mprotect (2).
.IP *
We can specify the
.BR MAP_STACK
flag to request a mapping that is suitable for a stack.
For the moment, this flag is a no-op on Linux,
but it exists and has effect on some other systems,
so we should include it for portability.
.SS Program source
.EX
#define _GNU_SOURCE
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sched.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \e
                        } while (0)

static int              /* Start function for cloned child */
childFunc(void *arg)
{
    struct utsname uts;

    /* Change hostname in UTS namespace of child */

    if (sethostname(arg, strlen(arg)) == \-1)
        errExit("sethostname");

    /* Retrieve and display hostname */

    if (uname(&uts) == \-1)
        errExit("uname");
    printf("uts.nodename in child:  %s\en", uts.nodename);

    /* Keep the namespace open for a while, by sleeping.
       This allows some experimentation\-\-for example, another
       process might join the namespace. */

    sleep(200);

    return 0;           /* Child terminates now */
}

#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */

int
main(int argc, char *argv[])
{
    char *stack;                    /* Start of stack buffer */
    char *stackTop;                 /* End of stack buffer */
    pid_t pid;
    struct utsname uts;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s <child\-hostname>\en", argv[0]);
        exit(EXIT_SUCCESS);
    }

    /* Allocate memory to be used for the stack of the child */

    stack = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, \-1, 0);
    if (stack == MAP_FAILED)
        errExit("mmap");

    stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */

    /* Create child that has its own UTS namespace;
       child commences execution in childFunc() */

    pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);
    if (pid == \-1)
        errExit("clone");
    printf("clone() returned %ld\en", (long) pid);

    /* Parent falls through to here */

    sleep(1);           /* Give child time to change its hostname */

    /* Display hostname in parent\(aqs UTS namespace. This will be
       different from hostname in child\(aqs UTS namespace. */

    if (uname(&uts) == \-1)
        errExit("uname");
    printf("uts.nodename in parent: %s\en", uts.nodename);

    if (waitpid(pid, NULL, 0) == \-1)    /* Wait for child */
        errExit("waitpid");
    printf("child has terminated\en");

    exit(EXIT_SUCCESS);
}
.EE
.SH SEE ALSO
.BR fork (2),
.BR futex (2),
.BR getpid (2),
.BR gettid (2),
.BR kcmp (2),
.BR mmap (2),
.BR pidfd_open (2),
.BR set_thread_area (2),
.BR set_tid_address (2),
.BR setns (2),
.BR tkill (2),
.BR unshare (2),
.BR wait (2),
.BR capabilities (7),
.BR namespaces (7),
.BR pthreads (7)
